!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/common"),require("@ngx-translate/core"),require("@shared/public-api"),require("@ngrx/store"),require("@angular/forms"),require("@core/public-api"),require("@angular/cdk/keycodes"),require("@home/components/public-api"),require("@angular/cdk/coercion"),require("@angular/material"),require("rxjs"),require("rxjs/operators")):"function"==typeof define&&define.amd?define("rulenode-core-config",["exports","@angular/core","@angular/common","@ngx-translate/core","@shared/public-api","@ngrx/store","@angular/forms","@core/public-api","@angular/cdk/keycodes","@home/components/public-api","@angular/cdk/coercion","@angular/material","rxjs","rxjs/operators"],t):t((e=e||self)["rulenode-core-config"]={},e.ng.core,e.ng.common,e["ngx-translate"],e.shared,e["ngrx-store"],e.ng.forms,e.core,e.ng.cdk.keycodes,e.publicApi$2,e.ng.cdk.coercion,e.ng.material,e.rxjs,e.rxjs.operators)}(this,(function(e,t,r,n,a,o,i,l,s,m,u,d,p,c){"use strict";
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */var f=function(e,t){return(f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)};function g(e,t){function r(){this.constructor=e}f(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}function y(e){var t="function"==typeof Symbol&&e[Symbol.iterator],r=0;return t?t.call(e):{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}var b=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.emptyConfigForm},r.prototype.onConfigurationSet=function(e){this.emptyConfigForm=this.fb.group({})},r.decorators=[{type:t.Component,args:[{selector:"tb-node-empty-config",template:"<div></div>"}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var h=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.attributeScopes=Object.keys(a.AttributeScope),n.telemetryTypeTranslationsMap=a.telemetryTypeTranslations,n}return g(r,e),r.prototype.configForm=function(){return this.attributesConfigForm},r.prototype.onConfigurationSet=function(e){this.attributesConfigForm=this.fb.group({scope:[e?e.scope:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-attributes-config",template:'<section [formGroup]="attributesConfigForm" fxLayout="column">\n  <mat-form-field fxFlex class="mat-block">\n    <mat-label translate>attribute.attributes-scope</mat-label>\n    <mat-select formControlName="scope" required>\n      <mat-option *ngFor="let scope of attributeScopes" [value]="scope">\n        {{ telemetryTypeTranslationsMap.get(scope) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var C=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.timeseriesConfigForm},r.prototype.onConfigurationSet=function(e){this.timeseriesConfigForm=this.fb.group({defaultTTL:[e?e.defaultTTL:null,[i.Validators.required,i.Validators.min(0)]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-timeseries-config",template:'<section [formGroup]="timeseriesConfigForm" fxLayout="column">\n  <mat-form-field fxFlex class="mat-block">\n    <mat-label translate>tb.rulenode.default-ttl</mat-label>\n    <input type="number" min="0" step="1" matInput formControlName="defaultTTL" required>\n    <mat-error *ngIf="timeseriesConfigForm.get(\'defaultTTL\').hasError(\'required\')">\n      {{ \'tb.rulenode.default-ttl-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="timeseriesConfigForm.get(\'defaultTTL\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-default-ttl-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var v=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.rpcRequestConfigForm},r.prototype.onConfigurationSet=function(e){this.rpcRequestConfigForm=this.fb.group({timeoutInSeconds:[e?e.timeoutInSeconds:null,[i.Validators.required,i.Validators.min(0)]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-rpc-request-config",template:'<section [formGroup]="rpcRequestConfigForm" fxLayout="column">\n  <mat-form-field fxFlex class="mat-block">\n    <mat-label translate>tb.rulenode.timeout-sec</mat-label>\n    <input type="number" min="0" step="1" matInput formControlName="timeoutInSeconds" required>\n    <mat-error *ngIf="rpcRequestConfigForm.get(\'timeoutInSeconds\').hasError(\'required\')">\n      {{ \'tb.rulenode.timeout-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="rpcRequestConfigForm.get(\'timeoutInSeconds\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-timeout-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var F=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.logConfigForm},r.prototype.onConfigurationSet=function(e){this.logConfigForm=this.fb.group({jsScript:[e?e.jsScript:null,[i.Validators.required]]})},r.prototype.testScript=function(){var e=this,t=this.logConfigForm.get("jsScript").value;this.nodeScriptTestService.testNodeScript(t,"string",this.translate.instant("tb.rulenode.to-string"),"ToString",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.logConfigForm.get("jsScript").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-log-config",template:'<section [formGroup]="logConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.to-string</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="jsScript"\n              functionName="ToString"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-to-string-function\' | translate }}\n    </button>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var T=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.assignCustomerConfigForm},r.prototype.onConfigurationSet=function(e){this.assignCustomerConfigForm=this.fb.group({customerNamePattern:[e?e.customerNamePattern:null,[i.Validators.required]],createCustomerIfNotExists:[!!e&&e.createCustomerIfNotExists,[]],customerCacheExpiration:[e?e.customerCacheExpiration:null,[i.Validators.required,i.Validators.min(0)]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-assign-to-customer-config",template:'<section [formGroup]="assignCustomerConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.customer-name-pattern</mat-label>\n    <input required matInput formControlName="customerNamePattern">\n    <mat-error *ngIf="assignCustomerConfigForm.get(\'customerNamePattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.customer-name-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.customer-name-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-checkbox fxFlex formControlName="createCustomerIfNotExists" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.create-customer-if-not-exists\' | translate }}\n  </mat-checkbox>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.customer-cache-expiration</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="customerCacheExpiration">\n    <mat-error *ngIf="assignCustomerConfigForm.get(\'customerCacheExpiration\').hasError(\'required\')">\n      {{ \'tb.rulenode.customer-cache-expiration-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="assignCustomerConfigForm.get(\'customerCacheExpiration\').hasError(\'min\')">\n      {{ \'tb.rulenode.customer-cache-expiration-range\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.customer-cache-expiration-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var q=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.clearAlarmConfigForm},r.prototype.onConfigurationSet=function(e){this.clearAlarmConfigForm=this.fb.group({alarmDetailsBuildJs:[e?e.alarmDetailsBuildJs:null,[i.Validators.required]],alarmType:[e?e.alarmType:null,[i.Validators.required]]})},r.prototype.testScript=function(){var e=this,t=this.clearAlarmConfigForm.get("alarmDetailsBuildJs").value;this.nodeScriptTestService.testNodeScript(t,"json",this.translate.instant("tb.rulenode.details"),"Details",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.clearAlarmConfigForm.get("alarmDetailsBuildJs").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-clear-alarm-config",template:'<section [formGroup]="clearAlarmConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.alarm-details-builder</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="alarmDetailsBuildJs"\n              functionName="Details"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row" style="padding-bottom: 16px;">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-details-function\' | translate }}\n    </button>\n  </div>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.alarm-type</mat-label>\n    <input required matInput formControlName="alarmType">\n    <mat-error *ngIf="clearAlarmConfigForm.get(\'alarmType\').hasError(\'required\')">\n      {{ \'tb.rulenode.alarm-type-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.entity-type-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var x=function(e){function r(t,r,n,o){var i=e.call(this,t)||this;return i.store=t,i.fb=r,i.nodeScriptTestService=n,i.translate=o,i.alarmSeverities=Object.keys(a.AlarmSeverity),i.alarmSeverityTranslationMap=a.alarmSeverityTranslations,i.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],i}return g(r,e),r.prototype.configForm=function(){return this.createAlarmConfigForm},r.prototype.onConfigurationSet=function(e){this.createAlarmConfigForm=this.fb.group({alarmDetailsBuildJs:[e?e.alarmDetailsBuildJs:null,[i.Validators.required]],useMessageAlarmData:[!!e&&e.useMessageAlarmData,[]],alarmType:[e?e.alarmType:null,[]],severity:[e?e.severity:null,[]],propagate:[!!e&&e.propagate,[]],relationTypes:[e?e.relationTypes:null,[]]})},r.prototype.validatorTriggers=function(){return["useMessageAlarmData"]},r.prototype.updateValidators=function(e){this.createAlarmConfigForm.get("useMessageAlarmData").value?(this.createAlarmConfigForm.get("alarmType").setValidators([]),this.createAlarmConfigForm.get("severity").setValidators([])):(this.createAlarmConfigForm.get("alarmType").setValidators([i.Validators.required]),this.createAlarmConfigForm.get("severity").setValidators([i.Validators.required])),this.createAlarmConfigForm.get("alarmType").updateValueAndValidity({emitEvent:e}),this.createAlarmConfigForm.get("severity").updateValueAndValidity({emitEvent:e})},r.prototype.testScript=function(){var e=this,t=this.createAlarmConfigForm.get("alarmDetailsBuildJs").value;this.nodeScriptTestService.testNodeScript(t,"json",this.translate.instant("tb.rulenode.details"),"Details",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.createAlarmConfigForm.get("alarmDetailsBuildJs").setValue(t)}))},r.prototype.removeKey=function(e,t){var r=this.createAlarmConfigForm.get(t).value,n=r.indexOf(e);n>=0&&(r.splice(n,1),this.createAlarmConfigForm.get(t).setValue(r,{emitEvent:!0}))},r.prototype.addKey=function(e,t){var r=e.input,n=e.value;if((n||"").trim()){n=n.trim();var a=this.createAlarmConfigForm.get(t).value;a&&-1!==a.indexOf(n)||(a||(a=[]),a.push(n),this.createAlarmConfigForm.get(t).setValue(a,{emitEvent:!0}))}r&&(r.value="")},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-create-alarm-config",template:'<section [formGroup]="createAlarmConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.alarm-details-builder</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="alarmDetailsBuildJs"\n              functionName="Details"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row" style="padding-bottom: 16px;">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-details-function\' | translate }}\n    </button>\n  </div>\n  <mat-checkbox formControlName="useMessageAlarmData" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.use-message-alarm-data\' | translate }}\n  </mat-checkbox>\n  <section fxLayout="column" *ngIf="createAlarmConfigForm.get(\'useMessageAlarmData\').value === false">\n    <section fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n      <mat-form-field fxFlex class="mat-block" style="padding-bottom: 16px;">\n        <mat-label translate>tb.rulenode.alarm-type</mat-label>\n        <input required matInput formControlName="alarmType">\n        <mat-error *ngIf="createAlarmConfigForm.get(\'alarmType\').hasError(\'required\')">\n          {{ \'tb.rulenode.alarm-type-required\' | translate }}\n        </mat-error>\n        <mat-hint innerHTML="{{ \'tb.rulenode.entity-type-pattern-hint\' | translate }}"></mat-hint>\n      </mat-form-field>\n      <mat-form-field fxFlex class="mat-block">\n        <mat-label translate>tb.rulenode.alarm-severity</mat-label>\n        <mat-select formControlName="severity" required>\n          <mat-option *ngFor="let severity of alarmSeverities" [value]="severity">\n            {{ alarmSeverityTranslationMap.get(severity) | translate }}\n          </mat-option>\n        </mat-select>\n        <mat-error *ngIf="createAlarmConfigForm.get(\'severity\').hasError(\'required\')">\n          {{ \'tb.rulenode.alarm-severity-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n    </section>\n    <mat-checkbox formControlName="propagate" style="padding-bottom: 16px;">\n      {{ \'tb.rulenode.propagate\' | translate }}\n    </mat-checkbox>\n    <section *ngIf="createAlarmConfigForm.get(\'propagate\').value === true">\n      <mat-form-field floatLabel="always" class="mat-block">\n        <mat-label translate>tb.rulenode.relation-types-list</mat-label>\n        <mat-chip-list #relationTypesChipList>\n          <mat-chip\n            *ngFor="let key of createAlarmConfigForm.get(\'relationTypes\').value;"\n            (removed)="removeKey(key, \'relationTypes\')">\n            {{key}}\n            <mat-icon matChipRemove>close</mat-icon>\n          </mat-chip>\n          <input matInput type="text" placeholder="{{\'tb.rulenode.relation-types-list\' | translate}}"\n                 style="max-width: 200px;"\n                 [matChipInputFor]="relationTypesChipList"\n                 [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n                 (matChipInputTokenEnd)="addKey($event, \'relationTypes\')"\n                 [matChipInputAddOnBlur]="true">\n        </mat-chip-list>\n        <mat-hint innerHTML="{{ \'tb.rulenode.relation-types-list-hint\' | translate }}"></mat-hint>\n      </mat-form-field>\n    </section>\n  </section>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var I=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.directionTypes=Object.keys(a.EntitySearchDirection),n.directionTypeTranslations=a.entitySearchDirectionTranslations,n.entityType=a.EntityType,n}return g(r,e),r.prototype.configForm=function(){return this.createRelationConfigForm},r.prototype.onConfigurationSet=function(e){this.createRelationConfigForm=this.fb.group({direction:[e?e.direction:null,[i.Validators.required]],entityType:[e?e.entityType:null,[i.Validators.required]],entityNamePattern:[e?e.entityNamePattern:null,[]],entityTypePattern:[e?e.entityTypePattern:null,[]],relationType:[e?e.relationType:null,[i.Validators.required]],createEntityIfNotExists:[!!e&&e.createEntityIfNotExists,[]],removeCurrentRelations:[!!e&&e.removeCurrentRelations,[]],changeOriginatorToRelatedEntity:[!!e&&e.changeOriginatorToRelatedEntity,[]],entityCacheExpiration:[e?e.entityCacheExpiration:null,[i.Validators.required,i.Validators.min(0)]]})},r.prototype.validatorTriggers=function(){return["entityType"]},r.prototype.updateValidators=function(e){var t=this.createRelationConfigForm.get("entityType").value;t?this.createRelationConfigForm.get("entityNamePattern").setValidators([i.Validators.required]):this.createRelationConfigForm.get("entityNamePattern").setValidators([]),!t||t!==a.EntityType.DEVICE&&t!==a.EntityType.ASSET?this.createRelationConfigForm.get("entityTypePattern").setValidators([]):this.createRelationConfigForm.get("entityTypePattern").setValidators([i.Validators.required]),this.createRelationConfigForm.get("entityNamePattern").updateValueAndValidity({emitEvent:e}),this.createRelationConfigForm.get("entityTypePattern").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-create-relation-config",template:'<section [formGroup]="createRelationConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="min-width: 100px;">\n    <mat-label translate>relation.direction</mat-label>\n    <mat-select required matInput formControlName="direction">\n      <mat-option *ngFor="let type of directionTypes" [value]="type">\n        {{ directionTypeTranslations.get(type) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <div fxLayout="row" fxLayoutGap="8px">\n    <tb-entity-type-select\n      showLabel\n      style="min-width: 100px;"\n      required\n      formControlName="entityType">\n    </tb-entity-type-select>\n    <mat-form-field *ngIf="createRelationConfigForm.get(\'entityType\').value" fxFlex class="mat-block" style="padding-bottom: 32px;">\n      <mat-label translate>tb.rulenode.entity-name-pattern</mat-label>\n      <input required matInput formControlName="entityNamePattern">\n      <mat-error *ngIf="createRelationConfigForm.get(\'entityNamePattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.entity-name-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.entity-name-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n    <mat-form-field *ngIf="createRelationConfigForm.get(\'entityType\').value === entityType.DEVICE ||\n                           createRelationConfigForm.get(\'entityType\').value === entityType.ASSET"\n                    fxFlex class="mat-block" style="padding-bottom: 32px;">\n      <mat-label translate>tb.rulenode.entity-type-pattern</mat-label>\n      <input required matInput formControlName="entityTypePattern">\n      <mat-error *ngIf="createRelationConfigForm.get(\'entityTypePattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.entity-type-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.entity-type-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n  </div>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.relation-type-pattern</mat-label>\n    <input required matInput formControlName="relationType">\n    <mat-error *ngIf="createRelationConfigForm.get(\'relationType\').hasError(\'required\')">\n      {{ \'tb.rulenode.relation-type-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.relation-type-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <section *ngIf="createRelationConfigForm.get(\'entityType\').value === entityType.CUSTOMER ||\n                  createRelationConfigForm.get(\'entityType\').value === entityType.DEVICE ||\n                  createRelationConfigForm.get(\'entityType\').value === entityType.ASSET">\n    <mat-checkbox formControlName="createEntityIfNotExists">\n      {{ \'tb.rulenode.create-entity-if-not-exists\' | translate }}\n    </mat-checkbox>\n    <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.create-entity-if-not-exists-hint</div>\n  </section>\n  <mat-checkbox formControlName="removeCurrentRelations">\n    {{ \'tb.rulenode.remove-current-relations\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.remove-current-relations-hint</div>\n  <mat-checkbox formControlName="changeOriginatorToRelatedEntity">\n    {{ \'tb.rulenode.change-originator-to-related-entity\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.change-originator-to-related-entity-hint</div>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.entity-cache-expiration</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="entityCacheExpiration">\n    <mat-error *ngIf="createRelationConfigForm.get(\'entityCacheExpiration\').hasError(\'required\')">\n      {{ \'tb.rulenode.entity-cache-expiration-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="createRelationConfigForm.get(\'entityCacheExpiration\').hasError(\'min\')">\n      {{ \'tb.rulenode.entity-cache-expiration-range\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.entity-cache-expiration-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var N=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.msgDelayConfigForm},r.prototype.onConfigurationSet=function(e){this.msgDelayConfigForm=this.fb.group({useMetadataPeriodInSecondsPatterns:[!!e&&e.useMetadataPeriodInSecondsPatterns,[]],periodInSeconds:[e?e.periodInSeconds:null,[]],periodInSecondsPattern:[e?e.periodInSecondsPattern:null,[]],maxPendingMsgs:[e?e.maxPendingMsgs:null,[i.Validators.required,i.Validators.min(1),i.Validators.max(1e5)]]})},r.prototype.validatorTriggers=function(){return["useMetadataPeriodInSecondsPatterns"]},r.prototype.updateValidators=function(e){this.msgDelayConfigForm.get("useMetadataPeriodInSecondsPatterns").value?(this.msgDelayConfigForm.get("periodInSecondsPattern").setValidators([i.Validators.required]),this.msgDelayConfigForm.get("periodInSeconds").setValidators([])):(this.msgDelayConfigForm.get("periodInSecondsPattern").setValidators([]),this.msgDelayConfigForm.get("periodInSeconds").setValidators([i.Validators.required,i.Validators.min(0)])),this.msgDelayConfigForm.get("periodInSecondsPattern").updateValueAndValidity({emitEvent:e}),this.msgDelayConfigForm.get("periodInSeconds").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-msg-delay-config",template:'<section [formGroup]="msgDelayConfigForm" fxLayout="column">\n  <mat-checkbox formControlName="useMetadataPeriodInSecondsPatterns">\n    {{ \'tb.rulenode.use-metadata-period-in-seconds-patterns\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.use-metadata-period-in-seconds-patterns-hint</div>\n  <mat-form-field *ngIf="msgDelayConfigForm.get(\'useMetadataPeriodInSecondsPatterns\').value !== true; else periodInSecondsPattern"\n                  class="mat-block">\n    <mat-label translate>tb.rulenode.period-seconds</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="periodInSeconds">\n    <mat-error *ngIf="msgDelayConfigForm.get(\'periodInSeconds\').hasError(\'required\')">\n      {{ \'tb.rulenode.period-seconds-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="msgDelayConfigForm.get(\'periodInSeconds\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-period-0-seconds-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <ng-template #periodInSecondsPattern>\n    <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.period-in-seconds-pattern</mat-label>\n      <input required matInput formControlName="periodInSecondsPattern">\n      <mat-error *ngIf="msgDelayConfigForm.get(\'periodInSecondsPattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.period-in-seconds-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.period-in-seconds-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n  </ng-template>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.max-pending-messages</mat-label>\n    <input required type="number" min="1" max="100000" step="1" matInput formControlName="maxPendingMsgs">\n    <mat-error *ngIf="msgDelayConfigForm.get(\'maxPendingMsgs\').hasError(\'required\')">\n      {{ \'tb.rulenode.max-pending-messages-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="msgDelayConfigForm.get(\'maxPendingMsgs\').hasError(\'min\')">\n      {{ \'tb.rulenode.max-pending-messages-range\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="msgDelayConfigForm.get(\'maxPendingMsgs\').hasError(\'max\')">\n      {{ \'tb.rulenode.max-pending-messages-range\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var k=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.directionTypes=Object.keys(a.EntitySearchDirection),n.directionTypeTranslations=a.entitySearchDirectionTranslations,n.entityType=a.EntityType,n}return g(r,e),r.prototype.configForm=function(){return this.deleteRelationConfigForm},r.prototype.onConfigurationSet=function(e){this.deleteRelationConfigForm=this.fb.group({deleteForSingleEntity:[!!e&&e.deleteForSingleEntity,[]],direction:[e?e.direction:null,[i.Validators.required]],entityType:[e?e.entityType:null,[]],entityNamePattern:[e?e.entityNamePattern:null,[]],relationType:[e?e.relationType:null,[i.Validators.required]],entityCacheExpiration:[e?e.entityCacheExpiration:null,[i.Validators.required,i.Validators.min(0)]]})},r.prototype.validatorTriggers=function(){return["deleteForSingleEntity","entityType"]},r.prototype.updateValidators=function(e){var t=this.deleteRelationConfigForm.get("deleteForSingleEntity").value,r=this.deleteRelationConfigForm.get("entityType").value;t?this.deleteRelationConfigForm.get("entityType").setValidators([i.Validators.required]):this.deleteRelationConfigForm.get("entityType").setValidators([]),t&&r?this.deleteRelationConfigForm.get("entityNamePattern").setValidators([i.Validators.required]):this.deleteRelationConfigForm.get("entityNamePattern").setValidators([]),this.deleteRelationConfigForm.get("entityType").updateValueAndValidity({emitEvent:!1}),this.deleteRelationConfigForm.get("entityNamePattern").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-delete-relation-config",template:'<section [formGroup]="deleteRelationConfigForm" fxLayout="column">\n  <mat-checkbox formControlName="deleteForSingleEntity">\n    {{ \'tb.rulenode.delete-relation-to-specific-entity\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.delete-relation-hint</div>\n  <mat-form-field class="mat-block" style="min-width: 100px;">\n    <mat-label translate>relation.direction</mat-label>\n    <mat-select required matInput formControlName="direction">\n      <mat-option *ngFor="let type of directionTypes" [value]="type">\n        {{ directionTypeTranslations.get(type) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <div *ngIf="deleteRelationConfigForm.get(\'deleteForSingleEntity\').value" fxLayout="row" fxLayoutGap="8px">\n    <tb-entity-type-select\n      showLabel\n      style="min-width: 100px;"\n      required\n      formControlName="entityType">\n    </tb-entity-type-select>\n    <mat-form-field *ngIf="deleteRelationConfigForm.get(\'entityType\').value" fxFlex class="mat-block" style="padding-bottom: 32px;">\n      <mat-label translate>tb.rulenode.entity-name-pattern</mat-label>\n      <input required matInput formControlName="entityNamePattern">\n      <mat-error *ngIf="deleteRelationConfigForm.get(\'entityNamePattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.entity-name-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.entity-name-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n  </div>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.relation-type-pattern</mat-label>\n    <input required matInput formControlName="relationType">\n    <mat-error *ngIf="deleteRelationConfigForm.get(\'relationType\').hasError(\'required\')">\n      {{ \'tb.rulenode.relation-type-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.relation-type-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.entity-cache-expiration</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="entityCacheExpiration">\n    <mat-error *ngIf="deleteRelationConfigForm.get(\'entityCacheExpiration\').hasError(\'required\')">\n      {{ \'tb.rulenode.entity-cache-expiration-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="deleteRelationConfigForm.get(\'entityCacheExpiration\').hasError(\'min\')">\n      {{ \'tb.rulenode.entity-cache-expiration-range\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.entity-cache-expiration-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var S=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.generatorConfigForm},r.prototype.onConfigurationSet=function(e){this.generatorConfigForm=this.fb.group({msgCount:[e?e.msgCount:null,[i.Validators.required,i.Validators.min(0)]],periodInSeconds:[e?e.periodInSeconds:null,[i.Validators.required,i.Validators.min(1)]],originator:[e?e.originator:null,[]],jsScript:[e?e.jsScript:null,[i.Validators.required]]})},r.prototype.prepareInputConfig=function(e){return e&&(e.originatorId&&e.originatorType?e.originator={id:e.originatorId,entityType:e.originatorType}:e.originator=null,delete e.originatorId,delete e.originatorType),e},r.prototype.prepareOutputConfig=function(e){return e.originator?(e.originatorId=e.originator.id,e.originatorType=e.originator.entityType):(e.originatorId=null,e.originatorType=null),delete e.originator,e},r.prototype.testScript=function(){var e=this,t=this.generatorConfigForm.get("jsScript").value;this.nodeScriptTestService.testNodeScript(t,"generate",this.translate.instant("tb.rulenode.generator"),"Generate",["prevMsg","prevMetadata","prevMsgType"],this.ruleNodeId).subscribe((function(t){t&&e.generatorConfigForm.get("jsScript").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-generator-config",template:'<section [formGroup]="generatorConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.message-count</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="msgCount">\n    <mat-error *ngIf="generatorConfigForm.get(\'msgCount\').hasError(\'required\')">\n      {{ \'tb.rulenode.message-count-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="generatorConfigForm.get(\'msgCount\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-message-count-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.period-seconds</mat-label>\n    <input required type="number" min="1" step="1" matInput formControlName="periodInSeconds">\n    <mat-error *ngIf="generatorConfigForm.get(\'periodInSeconds\').hasError(\'required\')">\n      {{ \'tb.rulenode.period-seconds-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="generatorConfigForm.get(\'periodInSeconds\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-period-seconds-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <div fxLayout="column">\n    <label class="tb-small">{{ \'tb.rulenode.originator\' | translate }}</label>\n    <tb-entity-select\n      required="false"\n      formControlName="originator">\n    </tb-entity-select>\n  </div>\n  <label translate class="tb-title no-padding">tb.rulenode.generate</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="jsScript"\n              functionName="Generate"\n              [functionArgs]="[\'prevMsg\', \'prevMetadata\', \'prevMsgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row" style="padding-bottom: 16px;">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-generator-function\' | translate }}\n    </button>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var V={CUSTOMER:"CUSTOMER",TENANT:"TENANT",RELATED:"RELATED",ALARM_ORIGINATOR:"ALARM_ORIGINATOR"},E=new Map([[V.CUSTOMER,"tb.rulenode.originator-customer"],[V.TENANT,"tb.rulenode.originator-tenant"],[V.RELATED,"tb.rulenode.originator-related"],[V.ALARM_ORIGINATOR,"tb.rulenode.originator-alarm-originator"]]),A={CIRCLE:"CIRCLE",POLYGON:"POLYGON"},L=new Map([[A.CIRCLE,"tb.rulenode.perimeter-circle"],[A.POLYGON,"tb.rulenode.perimeter-polygon"]]),M={MILLISECONDS:"MILLISECONDS",SECONDS:"SECONDS",MINUTES:"MINUTES",HOURS:"HOURS",DAYS:"DAYS"},R=new Map([[M.MILLISECONDS,"tb.rulenode.time-unit-milliseconds"],[M.SECONDS,"tb.rulenode.time-unit-seconds"],[M.MINUTES,"tb.rulenode.time-unit-minutes"],[M.HOURS,"tb.rulenode.time-unit-hours"],[M.DAYS,"tb.rulenode.time-unit-days"]]),D={METER:"METER",KILOMETER:"KILOMETER",FOOT:"FOOT",MILE:"MILE",NAUTICAL_MILE:"NAUTICAL_MILE"},P=new Map([[D.METER,"tb.rulenode.range-unit-meter"],[D.KILOMETER,"tb.rulenode.range-unit-kilometer"],[D.FOOT,"tb.rulenode.range-unit-foot"],[D.MILE,"tb.rulenode.range-unit-mile"],[D.NAUTICAL_MILE,"tb.rulenode.range-unit-nautical-mile"]]),w={TITLE:"TITLE",COUNTRY:"COUNTRY",STATE:"STATE",ZIP:"ZIP",ADDRESS:"ADDRESS",ADDRESS2:"ADDRESS2",PHONE:"PHONE",EMAIL:"EMAIL",ADDITIONAL_INFO:"ADDITIONAL_INFO"},O=new Map([[w.TITLE,"tb.rulenode.entity-details-title"],[w.COUNTRY,"tb.rulenode.entity-details-country"],[w.STATE,"tb.rulenode.entity-details-state"],[w.ZIP,"tb.rulenode.entity-details-zip"],[w.ADDRESS,"tb.rulenode.entity-details-address"],[w.ADDRESS2,"tb.rulenode.entity-details-address2"],[w.PHONE,"tb.rulenode.entity-details-phone"],[w.EMAIL,"tb.rulenode.entity-details-email"],[w.ADDITIONAL_INFO,"tb.rulenode.entity-details-additional_info"]]),K={FIRST:"FIRST",LAST:"LAST",ALL:"ALL"},j={ASC:"ASC",DESC:"DESC"},U={STANDARD:"STANDARD",FIFO:"FIFO"},G=new Map([[U.STANDARD,"tb.rulenode.sqs-queue-standard"],[U.FIFO,"tb.rulenode.sqs-queue-fifo"]]),B=["anonymous","basic","cert.PEM"],H=new Map([["anonymous","tb.rulenode.credentials-anonymous"],["basic","tb.rulenode.credentials-basic"],["cert.PEM","tb.rulenode.credentials-pem"]]),$=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.perimeterType=A,n.perimeterTypes=Object.keys(A),n.perimeterTypeTranslationMap=L,n.rangeUnits=Object.keys(D),n.rangeUnitTranslationMap=P,n.timeUnits=Object.keys(M),n.timeUnitsTranslationMap=R,n}return g(r,e),r.prototype.configForm=function(){return this.geoActionConfigForm},r.prototype.onConfigurationSet=function(e){this.geoActionConfigForm=this.fb.group({latitudeKeyName:[e?e.latitudeKeyName:null,[i.Validators.required]],longitudeKeyName:[e?e.longitudeKeyName:null,[i.Validators.required]],fetchPerimeterInfoFromMessageMetadata:[!!e&&e.fetchPerimeterInfoFromMessageMetadata,[]],perimeterType:[e?e.perimeterType:null,[]],centerLatitude:[e?e.centerLatitude:null,[]],centerLongitude:[e?e.centerLatitude:null,[]],range:[e?e.range:null,[]],rangeUnit:[e?e.rangeUnit:null,[]],polygonsDefinition:[e?e.polygonsDefinition:null,[]],minInsideDuration:[e?e.minInsideDuration:null,[i.Validators.required,i.Validators.min(1),i.Validators.max(2147483647)]],minInsideDurationTimeUnit:[e?e.minInsideDurationTimeUnit:null,[i.Validators.required]],minOutsideDuration:[e?e.minOutsideDuration:null,[i.Validators.required,i.Validators.min(1),i.Validators.max(2147483647)]],minOutsideDurationTimeUnit:[e?e.minOutsideDurationTimeUnit:null,[i.Validators.required]]})},r.prototype.validatorTriggers=function(){return["fetchPerimeterInfoFromMessageMetadata","perimeterType"]},r.prototype.updateValidators=function(e){var t=this.geoActionConfigForm.get("fetchPerimeterInfoFromMessageMetadata").value,r=this.geoActionConfigForm.get("perimeterType").value;t?this.geoActionConfigForm.get("perimeterType").setValidators([]):this.geoActionConfigForm.get("perimeterType").setValidators([i.Validators.required]),t||r!==A.CIRCLE?(this.geoActionConfigForm.get("centerLatitude").setValidators([]),this.geoActionConfigForm.get("centerLongitude").setValidators([]),this.geoActionConfigForm.get("range").setValidators([]),this.geoActionConfigForm.get("rangeUnit").setValidators([])):(this.geoActionConfigForm.get("centerLatitude").setValidators([i.Validators.required,i.Validators.min(-90),i.Validators.max(90)]),this.geoActionConfigForm.get("centerLongitude").setValidators([i.Validators.required,i.Validators.min(-180),i.Validators.max(180)]),this.geoActionConfigForm.get("range").setValidators([i.Validators.required,i.Validators.min(0)]),this.geoActionConfigForm.get("rangeUnit").setValidators([i.Validators.required])),t||r!==A.POLYGON?this.geoActionConfigForm.get("polygonsDefinition").setValidators([]):this.geoActionConfigForm.get("polygonsDefinition").setValidators([i.Validators.required]),this.geoActionConfigForm.get("perimeterType").updateValueAndValidity({emitEvent:!1}),this.geoActionConfigForm.get("centerLatitude").updateValueAndValidity({emitEvent:e}),this.geoActionConfigForm.get("centerLongitude").updateValueAndValidity({emitEvent:e}),this.geoActionConfigForm.get("range").updateValueAndValidity({emitEvent:e}),this.geoActionConfigForm.get("rangeUnit").updateValueAndValidity({emitEvent:e}),this.geoActionConfigForm.get("polygonsDefinition").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-gps-geofencing-config",template:'<section [formGroup]="geoActionConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.latitude-key-name</mat-label>\n    <input matInput formControlName="latitudeKeyName" required>\n    <mat-error *ngIf="geoActionConfigForm.get(\'latitudeKeyName\').hasError(\'required\')">\n      {{ \'tb.rulenode.latitude-key-name-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.longitude-key-name</mat-label>\n    <input matInput formControlName="longitudeKeyName" required>\n    <mat-error *ngIf="geoActionConfigForm.get(\'longitudeKeyName\').hasError(\'required\')">\n      {{ \'tb.rulenode.longitude-key-name-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-checkbox fxFlex formControlName="fetchPerimeterInfoFromMessageMetadata" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.fetch-perimeter-info-from-message-metadata\' | translate }}\n  </mat-checkbox>\n  <div fxLayout="row" *ngIf="!geoActionConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.perimeter-type</mat-label>\n      <mat-select formControlName="perimeterType" required>\n        <mat-option *ngFor="let type of perimeterTypes" [value]="type">\n          {{ perimeterTypeTranslationMap.get(type) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n  <div fxLayout="column"\n       *ngIf="geoActionConfigForm.get(\'perimeterType\').value === perimeterType.CIRCLE &&\n       !geoActionConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <div fxLayout="row" fxLayoutGap="8px">\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.circle-center-latitude</mat-label>\n        <input type="number" min="-90" max="90" step="0.1" matInput formControlName="centerLatitude" required>\n        <mat-error *ngIf="geoActionConfigForm.get(\'centerLatitude\').hasError(\'required\')">\n          {{ \'tb.rulenode.circle-center-latitude-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.circle-center-longitude</mat-label>\n        <input type="number" min="-180" max="180" step="0.1" matInput formControlName="centerLongitude" required>\n        <mat-error *ngIf="geoActionConfigForm.get(\'centerLongitude\').hasError(\'required\')">\n          {{ \'tb.rulenode.circle-center-longitude-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n    </div>\n    <div fxLayout="row" fxLayoutGap="8px">\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.range</mat-label>\n        <input type="number" min="0" step="0.1" matInput formControlName="range" required>\n        <mat-error *ngIf="geoActionConfigForm.get(\'range\').hasError(\'required\')">\n          {{ \'tb.rulenode.range-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.range-units</mat-label>\n        <mat-select formControlName="rangeUnit" required>\n          <mat-option *ngFor="let type of rangeUnits" [value]="type">\n            {{ rangeUnitTranslationMap.get(type) | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n  <div fxLayout="column" *ngIf="geoActionConfigForm.get(\'perimeterType\').value === perimeterType.POLYGON &&\n                             !geoActionConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <mat-form-field class="mat-block" hintLabel="{{\'tb.rulenode.polygon-definition-hint\' | translate}}" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.polygon-definition</mat-label>\n      <input matInput formControlName="polygonsDefinition" required>\n      <mat-error *ngIf="geoActionConfigForm.get(\'polygonsDefinition\').hasError(\'required\')">\n        {{ \'tb.rulenode.polygon-definition-required\' | translate }}\n      </mat-error>\n    </mat-form-field>\n  </div>\n  <div fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.min-inside-duration</mat-label>\n      <input type="number" step="1" min="1" max="2147483647" matInput formControlName="minInsideDuration" required>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minInsideDuration\').hasError(\'required\')">\n        {{ \'tb.rulenode.min-inside-duration-value-required\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minInsideDuration\').hasError(\'min\')">\n        {{ \'tb.rulenode.time-value-range\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minInsideDuration\').hasError(\'max\')">\n        {{ \'tb.rulenode.time-value-range\' | translate }}\n      </mat-error>\n    </mat-form-field>\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.min-inside-duration-time-unit</mat-label>\n      <mat-select formControlName="minInsideDurationTimeUnit" required>\n        <mat-option *ngFor="let timeUnit of timeUnits" [value]="timeUnit">\n          {{ timeUnitsTranslationMap.get(timeUnit) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n  <div fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.min-outside-duration</mat-label>\n      <input type="number" step="1" min="1" max="2147483647" matInput formControlName="minOutsideDuration" required>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minOutsideDuration\').hasError(\'required\')">\n        {{ \'tb.rulenode.min-outside-duration-value-required\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minOutsideDuration\').hasError(\'min\')">\n        {{ \'tb.rulenode.time-value-range\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="geoActionConfigForm.get(\'minOutsideDuration\').hasError(\'max\')">\n        {{ \'tb.rulenode.time-value-range\' | translate }}\n      </mat-error>\n    </mat-form-field>\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.min-outside-duration-time-unit</mat-label>\n      <mat-select formControlName="minOutsideDurationTimeUnit" required>\n        <mat-option *ngFor="let timeUnit of timeUnits" [value]="timeUnit">\n          {{ timeUnitsTranslationMap.get(timeUnit) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var Q=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.msgCountConfigForm},r.prototype.onConfigurationSet=function(e){this.msgCountConfigForm=this.fb.group({interval:[e?e.interval:null,[i.Validators.required,i.Validators.min(1)]],telemetryPrefix:[e?e.telemetryPrefix:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-msg-count-config",template:'<section [formGroup]="msgCountConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.interval-seconds</mat-label>\n    <input required type="number" min="1" step="1" matInput formControlName="interval">\n    <mat-error *ngIf="msgCountConfigForm.get(\'interval\').hasError(\'required\')">\n      {{ \'tb.rulenode.interval-seconds-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="msgCountConfigForm.get(\'interval\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-interval-seconds-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.output-timeseries-key-prefix</mat-label>\n    <input required matInput formControlName="telemetryPrefix">\n    <mat-error *ngIf="msgCountConfigForm.get(\'telemetryPrefix\').hasError(\'required\')">\n      {{ \'tb.rulenode.output-timeseries-key-prefix-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var z=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.rpcReplyConfigForm},r.prototype.onConfigurationSet=function(e){this.rpcReplyConfigForm=this.fb.group({requestIdMetaDataAttribute:[e?e.requestIdMetaDataAttribute:null,[]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-rpc-reply-config",template:'<section [formGroup]="rpcReplyConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.request-id-metadata-attribute</mat-label>\n    <input matInput formControlName="requestIdMetaDataAttribute">\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var _=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.saveToCustomTableConfigForm},r.prototype.onConfigurationSet=function(e){this.saveToCustomTableConfigForm=this.fb.group({tableName:[e?e.tableName:null,[i.Validators.required]],fieldsMapping:[e?e.fieldsMapping:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-custom-table-config",template:'<section [formGroup]="saveToCustomTableConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.custom-table-name</mat-label>\n    <input required matInput formControlName="tableName">\n    <mat-error *ngIf="saveToCustomTableConfigForm.get(\'tableName\').hasError(\'required\')">\n      {{ \'tb.rulenode.custom-table-name-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.custom-table-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <label translate class="tb-title tb-required">tb.rulenode.fields-mapping</label>\n  <tb-kv-map-config\n    required\n    formControlName="fieldsMapping"\n    requiredText="tb.rulenode.fields-mapping-required"\n    keyText="tb.rulenode.message-field"\n    keyRequiredText="tb.rulenode.message-field-required"\n    valText="tb.rulenode.table-col"\n    valRequiredText="tb.rulenode.table-col-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var W=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.translate=r,o.injector=n,o.fb=a,o.propagateChange=null,o.valueChangeSubscription=null,o}return g(r,e),Object.defineProperty(r.prototype,"required",{get:function(){return this.requiredValue},set:function(e){this.requiredValue=u.coerceBooleanProperty(e)},enumerable:!0,configurable:!0}),r.prototype.ngOnInit=function(){this.ngControl=this.injector.get(i.NgControl),null!=this.ngControl&&(this.ngControl.valueAccessor=this),this.kvListFormGroup=this.fb.group({}),this.kvListFormGroup.addControl("keyVals",this.fb.array([]))},r.prototype.keyValsFormArray=function(){return this.kvListFormGroup.get("keyVals")},r.prototype.registerOnChange=function(e){this.propagateChange=e},r.prototype.registerOnTouched=function(e){},r.prototype.setDisabledState=function(e){this.disabled=e,this.disabled?this.kvListFormGroup.disable({emitEvent:!1}):this.kvListFormGroup.enable({emitEvent:!1})},r.prototype.writeValue=function(e){var t,r,n=this;this.valueChangeSubscription&&this.valueChangeSubscription.unsubscribe();var a=[];if(e)try{for(var o=y(Object.keys(e)),l=o.next();!l.done;l=o.next()){var s=l.value;Object.prototype.hasOwnProperty.call(e,s)&&a.push(this.fb.group({key:[s,[i.Validators.required]],value:[e[s],[i.Validators.required]]}))}}catch(e){t={error:e}}finally{try{l&&!l.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}this.kvListFormGroup.setControl("keyVals",this.fb.array(a)),this.valueChangeSubscription=this.kvListFormGroup.valueChanges.subscribe((function(){n.updateModel()}))},r.prototype.removeKeyVal=function(e){this.kvListFormGroup.get("keyVals").removeAt(e)},r.prototype.addKeyVal=function(){this.kvListFormGroup.get("keyVals").push(this.fb.group({key:["",[i.Validators.required]],value:["",[i.Validators.required]]}))},r.prototype.validate=function(e){return!this.kvListFormGroup.get("keyVals").value.length&&this.required?{kvMapRequired:!0}:this.kvListFormGroup.valid?null:{kvFieldsRequired:!0}},r.prototype.updateModel=function(){var e=this.kvListFormGroup.get("keyVals").value;if(this.required&&!e.length||!this.kvListFormGroup.valid)this.propagateChange(null);else{var t={};e.forEach((function(e){t[e.key]=e.value})),this.propagateChange(t)}},r.decorators=[{type:t.Component,args:[{selector:"tb-kv-map-config",template:'<section fxLayout="column" class="tb-kv-map-config" [formGroup]="kvListFormGroup">\n  <div class="header" fxFlex fxLayout="row" fxLayoutGap="8px">\n    <span class="cell" fxFlex translate>{{ keyText }}</span>\n    <span class="cell" fxFlex translate>{{ valText }}</span>\n    <span [fxShow]="!disabled" style="width: 52px;" innerHTML="&nbsp"></span>\n  </div>\n  <div class="body">\n    <div class="row" fxLayout="row" fxLayoutAlign="start center" fxLayoutGap="8px"\n         formArrayName="keyVals"\n         *ngFor="let keyValControl of keyValsFormArray().controls; let $index = index">\n      <mat-form-field fxFlex floatLabel="always" hideRequiredMarker class="cell mat-block">\n        <mat-label></mat-label>\n        <input [formControl]="keyValControl.get(\'key\')" matInput required\n               placeholder="{{ keyText | translate }}"/>\n        <mat-error *ngIf="keyValControl.get(\'key\').hasError(\'required\')">\n          {{ keyRequiredText | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex floatLabel="always" hideRequiredMarker class="cell mat-block">\n        <mat-label></mat-label>\n        <input [formControl]="keyValControl.get(\'value\')" matInput required\n               placeholder="{{ valText | translate }}"/>\n        <mat-error *ngIf="keyValControl.get(\'value\').hasError(\'required\')">\n          {{ valRequiredText | translate }}\n        </mat-error>\n      </mat-form-field>\n      <button mat-button mat-icon-button color="primary"\n              [fxShow]="!disabled"\n              type="button"\n              (click)="removeKeyVal($index)"\n              [disabled]="isLoading$ | async"\n              matTooltip="{{ \'tb.key-val.remove-entry\' | translate }}"\n              matTooltipPosition="above">\n        <mat-icon>close</mat-icon>\n      </button>\n    </div>\n  </div>\n  <tb-error [error]="ngControl.hasError(\'kvMapRequired\')\n                  ? translate.instant(requiredText) : \'\'"></tb-error>\n  <div style="margin-top: 8px;">\n    <button mat-button mat-raised-button color="primary"\n            [fxShow]="!disabled"\n            [disabled]="isLoading$ | async"\n            (click)="addKeyVal()"\n            type="button"\n            matTooltip="{{ \'tb.key-val.add-entry\' | translate }}"\n            matTooltipPosition="above">\n      <mat-icon>add</mat-icon>\n      {{ \'action.add\' | translate }}\n    </button>\n  </div>\n</section>\n',providers:[{provide:i.NG_VALUE_ACCESSOR,useExisting:t.forwardRef((function(){return r})),multi:!0},{provide:i.NG_VALIDATORS,useExisting:t.forwardRef((function(){return r})),multi:!0}],styles:[":host .tb-kv-map-config{margin-bottom:16px}:host .tb-kv-map-config .header{padding-left:5px;padding-right:5px;padding-bottom:5px}:host .tb-kv-map-config .header .cell{padding-left:5px;padding-right:5px;color:rgba(0,0,0,.54);font-size:12px;font-weight:700;white-space:nowrap}:host .tb-kv-map-config .body{padding-left:5px;padding-right:5px;padding-bottom:20px;max-height:300px;overflow:auto}:host .tb-kv-map-config .body .row{padding-top:5px;max-height:40px}:host .tb-kv-map-config .body .cell{padding-left:5px;padding-right:5px}:host ::ng-deep .tb-kv-map-config .body mat-form-field.cell{margin:0;max-height:40px}:host ::ng-deep .tb-kv-map-config .body mat-form-field.cell .mat-form-field-infix{border-top:0}:host ::ng-deep .tb-kv-map-config .body button.mat-button{margin:0}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:n.TranslateService},{type:t.Injector},{type:i.FormBuilder}]},r.propDecorators={disabled:[{type:t.Input}],requiredText:[{type:t.Input}],keyText:[{type:t.Input}],keyRequiredText:[{type:t.Input}],valText:[{type:t.Input}],valRequiredText:[{type:t.Input}],required:[{type:t.Input}]},r}(a.PageComponent);var Y=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.directionTypes=Object.keys(a.EntitySearchDirection),n.directionTypeTranslations=a.entitySearchDirectionTranslations,n.entityType=a.EntityType,n.propagateChange=null,n}return g(r,e),Object.defineProperty(r.prototype,"required",{get:function(){return this.requiredValue},set:function(e){this.requiredValue=u.coerceBooleanProperty(e)},enumerable:!0,configurable:!0}),r.prototype.ngOnInit=function(){var e=this;this.deviceRelationsQueryFormGroup=this.fb.group({direction:[null,[i.Validators.required]],maxLevel:[null,[]],relationType:[null],deviceTypes:[null,[i.Validators.required]]}),this.deviceRelationsQueryFormGroup.valueChanges.subscribe((function(t){e.deviceRelationsQueryFormGroup.valid?e.propagateChange(t):e.propagateChange(null)}))},r.prototype.registerOnChange=function(e){this.propagateChange=e},r.prototype.registerOnTouched=function(e){},r.prototype.setDisabledState=function(e){this.disabled=e,this.disabled?this.deviceRelationsQueryFormGroup.disable({emitEvent:!1}):this.deviceRelationsQueryFormGroup.enable({emitEvent:!1})},r.prototype.writeValue=function(e){this.deviceRelationsQueryFormGroup.reset(e,{emitEvent:!1})},r.decorators=[{type:t.Component,args:[{selector:"tb-device-relations-query-config",template:'<section fxLayout="column" [formGroup]="deviceRelationsQueryFormGroup">\n  <div fxLayoutGap="8px" fxLayout="row">\n    <mat-form-field class="mat-block" style="min-width: 100px;">\n      <mat-label translate>relation.direction</mat-label>\n      <mat-select required matInput formControlName="direction">\n        <mat-option *ngFor="let type of directionTypes" [value]="type">\n          {{ directionTypeTranslations.get(type) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <mat-form-field fxFlex floatLabel="always" class="mat-block">\n      <mat-label translate>tb.rulenode.max-relation-level</mat-label>\n      <input matInput\n             type="number"\n             min="1"\n             step="1"\n             placeholder="{{ \'tb.rulenode.unlimited-level\' | translate }}"\n             formControlName="maxLevel">\n    </mat-form-field>\n  </div>\n  <div class="mat-caption" style="color: rgba(0,0,0,0.57);" translate>relation.relation-type</div>\n  <tb-relation-type-autocomplete\n    fxFlex\n    formControlName="relationType">\n  </tb-relation-type-autocomplete>\n  <div class="mat-caption tb-required" style="color: rgba(0,0,0,0.57);" translate>device.device-types</div>\n  <tb-entity-subtype-list\n    required\n    [entityType]="entityType.DEVICE"\n    formControlName="deviceTypes">\n  </tb-entity-subtype-list>\n</section>\n',providers:[{provide:i.NG_VALUE_ACCESSOR,useExisting:t.forwardRef((function(){return r})),multi:!0}]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r.propDecorators={disabled:[{type:t.Input}],required:[{type:t.Input}]},r}(a.PageComponent);var J=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.directionTypes=Object.keys(a.EntitySearchDirection),n.directionTypeTranslations=a.entitySearchDirectionTranslations,n.propagateChange=null,n}return g(r,e),Object.defineProperty(r.prototype,"required",{get:function(){return this.requiredValue},set:function(e){this.requiredValue=u.coerceBooleanProperty(e)},enumerable:!0,configurable:!0}),r.prototype.ngOnInit=function(){var e=this;this.relationsQueryFormGroup=this.fb.group({direction:[null,[i.Validators.required]],maxLevel:[null,[]],filters:[null]}),this.relationsQueryFormGroup.valueChanges.subscribe((function(t){e.relationsQueryFormGroup.valid?e.propagateChange(t):e.propagateChange(null)}))},r.prototype.registerOnChange=function(e){this.propagateChange=e},r.prototype.registerOnTouched=function(e){},r.prototype.setDisabledState=function(e){this.disabled=e,this.disabled?this.relationsQueryFormGroup.disable({emitEvent:!1}):this.relationsQueryFormGroup.enable({emitEvent:!1})},r.prototype.writeValue=function(e){this.relationsQueryFormGroup.reset(e,{emitEvent:!1})},r.decorators=[{type:t.Component,args:[{selector:"tb-relations-query-config",template:'<section fxLayout="column" [formGroup]="relationsQueryFormGroup">\n  <div fxLayoutGap="8px" fxLayout="row">\n    <mat-form-field class="mat-block" style="min-width: 100px;">\n      <mat-label translate>relation.direction</mat-label>\n      <mat-select required matInput formControlName="direction">\n        <mat-option *ngFor="let type of directionTypes" [value]="type">\n          {{ directionTypeTranslations.get(type) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <mat-form-field fxFlex floatLabel="always" class="mat-block">\n      <mat-label translate>tb.rulenode.max-relation-level</mat-label>\n      <input matInput\n             type="number"\n             min="1"\n             step="1"\n             placeholder="{{ \'tb.rulenode.unlimited-level\' | translate }}"\n             formControlName="maxLevel">\n    </mat-form-field>\n  </div>\n  <div class="mat-caption" style="color: rgba(0,0,0,0.57);" translate>relation.relation-filters</div>\n  <tb-relation-filters\n    formControlName="filters"\n  ></tb-relation-filters>\n</section>\n',providers:[{provide:i.NG_VALUE_ACCESSOR,useExisting:t.forwardRef((function(){return r})),multi:!0}]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r.propDecorators={disabled:[{type:t.Input}],required:[{type:t.Input}]},r}(a.PageComponent);var Z=function(e){function r(t,r,n,o){var i,l,m=e.call(this,t)||this;m.store=t,m.translate=r,m.truncate=n,m.fb=o,m.placeholder="tb.rulenode.message-type",m.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],m.messageTypes=[],m.messageTypesList=[],m.searchText="",m.propagateChange=function(e){},m.messageTypeConfigForm=m.fb.group({messageType:[null]});try{for(var u=y(Object.keys(a.MessageType)),d=u.next();!d.done;d=u.next()){var p=d.value;m.messageTypesList.push({name:a.messageTypeNames.get(a.MessageType[p]),value:p})}}catch(e){i={error:e}}finally{try{d&&!d.done&&(l=u.return)&&l.call(u)}finally{if(i)throw i.error}}return m}return g(r,e),Object.defineProperty(r.prototype,"required",{get:function(){return this.requiredValue},set:function(e){this.requiredValue=u.coerceBooleanProperty(e)},enumerable:!0,configurable:!0}),r.prototype.registerOnChange=function(e){this.propagateChange=e},r.prototype.registerOnTouched=function(e){},r.prototype.ngOnInit=function(){var e=this;this.filteredMessageTypes=this.messageTypeConfigForm.get("messageType").valueChanges.pipe(c.startWith(""),c.map((function(e){return e||""})),c.mergeMap((function(t){return e.fetchMessageTypes(t)})),c.share())},r.prototype.ngAfterViewInit=function(){},r.prototype.setDisabledState=function(e){this.disabled=e,this.disabled?this.messageTypeConfigForm.disable({emitEvent:!1}):this.messageTypeConfigForm.enable({emitEvent:!1})},r.prototype.writeValue=function(e){var t=this;this.searchText="",this.messageTypes.length=0,e&&e.forEach((function(e){var r=t.messageTypesList.find((function(t){return t.value===e}));r?t.messageTypes.push({name:r.name,value:r.value}):t.messageTypes.push({name:e,value:e})}))},r.prototype.displayMessageTypeFn=function(e){return e?e.name:void 0},r.prototype.textIsNotEmpty=function(e){return!!(e&&null!=e&&e.length>0)},r.prototype.createMessageType=function(e,t){e.preventDefault(),this.transformMessageType(t)},r.prototype.add=function(e){this.transformMessageType(e.value)},r.prototype.fetchMessageTypes=function(e){if(this.searchText=e,this.searchText&&this.searchText.length){var t=this.searchText.toUpperCase();return p.of(this.messageTypesList.filter((function(e){return e.name.toUpperCase().includes(t)})))}return p.of(this.messageTypesList)},r.prototype.transformMessageType=function(e){if((e||"").trim()){var t=null,r=e.trim(),n=this.messageTypesList.find((function(e){return e.name===r}));(t=n?{name:n.name,value:n.value}:{name:r,value:r})&&this.addMessageType(t)}this.clear("")},r.prototype.remove=function(e){var t=this.messageTypes.indexOf(e);t>=0&&(this.messageTypes.splice(t,1),this.updateModel())},r.prototype.selected=function(e){this.addMessageType(e.option.value),this.clear("")},r.prototype.addMessageType=function(e){-1===this.messageTypes.findIndex((function(t){return t.value===e.value}))&&(this.messageTypes.push(e),this.updateModel())},r.prototype.clear=function(e){var t=this;void 0===e&&(e=""),this.messageTypeInput.nativeElement.value=e,this.messageTypeConfigForm.get("messageType").patchValue(null,{emitEvent:!0}),setTimeout((function(){t.messageTypeInput.nativeElement.blur(),t.messageTypeInput.nativeElement.focus()}),0)},r.prototype.updateModel=function(){var e=this.messageTypes.map((function(e){return e.value}));this.required?(this.chipList.errorState=!e.length,this.propagateChange(e.length>0?e:null)):(this.chipList.errorState=!1,this.propagateChange(e))},r.decorators=[{type:t.Component,args:[{selector:"tb-message-types-config",template:'<mat-form-field [formGroup]="messageTypeConfigForm" style="width: 100%;">\n  <mat-label *ngIf="label" translate>{{ label }}</mat-label>\n  <mat-chip-list #chipList [required]="required">\n    <mat-chip\n      *ngFor="let messageType of messageTypes"\n      [selectable]="true"\n      [removable]="true"\n      (removed)="remove(messageType)">\n      {{messageType.name}}\n      <mat-icon matChipRemove>close</mat-icon>\n    </mat-chip>\n    <input matInput type="text" placeholder="{{ placeholder | translate }}"\n           style="max-width: 200px;"\n           #messageTypeInput\n           formControlName="messageType"\n           matAutocompleteOrigin\n           #origin="matAutocompleteOrigin"\n           [matAutocompleteConnectedTo]="origin"\n           [matAutocomplete]="messageTypeAutocomplete"\n           [matChipInputFor]="chipList"\n           [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n           (matChipInputTokenEnd)="add($event)">\n  </mat-chip-list>\n  <mat-autocomplete #messageTypeAutocomplete="matAutocomplete"\n                    class="tb-autocomplete"\n                    (optionSelected)="selected($event)"\n                    [displayWith]="displayMessageTypeFn">\n    <mat-option *ngFor="let messageType of filteredMessageTypes | async" [value]="messageType">\n      <span [innerHTML]="messageType.name | highlight:searchText"></span>\n    </mat-option>\n    <mat-option *ngIf="(filteredMessageTypes | async)?.length === 0" [value]="null" class="tb-not-found">\n      <div class="tb-not-found-content" (click)="$event.stopPropagation()">\n        <div *ngIf="!textIsNotEmpty(searchText); else searchNotEmpty">\n          <span translate>tb.rulenode.no-message-types-found</span>\n        </div>\n        <ng-template #searchNotEmpty>\n                <span>\n                  {{ translate.get(\'tb.rulenode.no-message-type-matching\',\n                  {messageType: truncate.transform(searchText, true, 6, &apos;...&apos;)}) | async }}\n                </span>\n        </ng-template>\n        <span>\n          <a translate (click)="createMessageType($event, searchText)">tb.rulenode.create-new-message-type</a>\n        </span>\n      </div>\n    </mat-option>\n  </mat-autocomplete>\n  <mat-error *ngIf="chipList.errorState">\n    {{ \'tb.rulenode.message-types-required\' | translate }}\n  </mat-error>\n</mat-form-field>\n',providers:[{provide:i.NG_VALUE_ACCESSOR,useExisting:t.forwardRef((function(){return r})),multi:!0}]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:n.TranslateService},{type:a.TruncatePipe},{type:i.FormBuilder}]},r.propDecorators={required:[{type:t.Input}],label:[{type:t.Input}],placeholder:[{type:t.Input}],disabled:[{type:t.Input}],chipList:[{type:t.ViewChild,args:["chipList",{static:!1}]}],matAutocomplete:[{type:t.ViewChild,args:["messageTypeAutocomplete",{static:!1}]}],messageTypeInput:[{type:t.ViewChild,args:["messageTypeInput",{static:!1}]}]},r}(a.PageComponent);var X=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{declarations:[W,Y,J,Z],imports:[r.CommonModule,a.SharedModule,m.HomeComponentsModule],exports:[W,Y,J,Z]}]}],e}(),ee=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.unassignCustomerConfigForm},r.prototype.onConfigurationSet=function(e){this.unassignCustomerConfigForm=this.fb.group({customerNamePattern:[e?e.customerNamePattern:null,[i.Validators.required]],customerCacheExpiration:[e?e.customerCacheExpiration:null,[i.Validators.required,i.Validators.min(0)]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-un-assign-to-customer-config",template:'<section [formGroup]="unassignCustomerConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.customer-name-pattern</mat-label>\n    <input required matInput formControlName="customerNamePattern">\n    <mat-error *ngIf="unassignCustomerConfigForm.get(\'customerNamePattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.customer-name-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.customer-name-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.customer-cache-expiration</mat-label>\n    <input required type="number" min="0" step="1" matInput formControlName="customerCacheExpiration">\n    <mat-error *ngIf="unassignCustomerConfigForm.get(\'customerCacheExpiration\').hasError(\'required\')">\n      {{ \'tb.rulenode.customer-cache-expiration-required\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="unassignCustomerConfigForm.get(\'customerCacheExpiration\').hasError(\'min\')">\n      {{ \'tb.rulenode.customer-cache-expiration-range\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.customer-cache-expiration-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var te=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.snsConfigForm},r.prototype.onConfigurationSet=function(e){this.snsConfigForm=this.fb.group({topicArnPattern:[e?e.topicArnPattern:null,[i.Validators.required]],accessKeyId:[e?e.accessKeyId:null,[i.Validators.required]],secretAccessKey:[e?e.secretAccessKey:null,[i.Validators.required]],region:[e?e.region:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-sns-config",template:'<section [formGroup]="snsConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.topic-arn-pattern</mat-label>\n    <input required matInput formControlName="topicArnPattern">\n    <mat-error *ngIf="snsConfigForm.get(\'topicArnPattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.topic-arn-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.topic-arn-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-access-key-id</mat-label>\n    <input required matInput formControlName="accessKeyId">\n    <mat-error *ngIf="snsConfigForm.get(\'accessKeyId\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-access-key-id-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-secret-access-key</mat-label>\n    <input required matInput formControlName="secretAccessKey">\n    <mat-error *ngIf="snsConfigForm.get(\'secretAccessKey\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-secret-access-key-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-region</mat-label>\n    <input required matInput formControlName="region">\n    <mat-error *ngIf="snsConfigForm.get(\'region\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-region-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var re=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.sqsQueueType=U,n.sqsQueueTypes=Object.keys(U),n.sqsQueueTypeTranslationsMap=G,n}return g(r,e),r.prototype.configForm=function(){return this.sqsConfigForm},r.prototype.onConfigurationSet=function(e){this.sqsConfigForm=this.fb.group({queueType:[e?e.queueType:null,[i.Validators.required]],queueUrlPattern:[e?e.queueUrlPattern:null,[i.Validators.required]],delaySeconds:[e?e.delaySeconds:null,[i.Validators.min(0),i.Validators.max(900)]],messageAttributes:[e?e.messageAttributes:null,[]],accessKeyId:[e?e.accessKeyId:null,[i.Validators.required]],secretAccessKey:[e?e.secretAccessKey:null,[i.Validators.required]],region:[e?e.region:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-sqs-config",template:'<section [formGroup]="sqsConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.queue-type</mat-label>\n    <mat-select formControlName="queueType" required>\n      <mat-option *ngFor="let type of sqsQueueTypes" [value]="type">\n        {{ sqsQueueTypeTranslationsMap.get(type) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.queue-url-pattern</mat-label>\n    <input required matInput formControlName="queueUrlPattern">\n    <mat-error *ngIf="sqsConfigForm.get(\'queueUrlPattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.queue-url-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.queue-url-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field *ngIf="sqsConfigForm.get(\'queueType\').value === sqsQueueType.STANDARD" class="mat-block">\n    <mat-label translate>tb.rulenode.delay-seconds</mat-label>\n    <input required type="number" min="0" max="900" step="1" matInput formControlName="delaySeconds">\n    <mat-error *ngIf="sqsConfigForm.get(\'delaySeconds\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-delay-seconds-message\' | translate }}\n    </mat-error>\n    <mat-error *ngIf="sqsConfigForm.get(\'delaySeconds\').hasError(\'max\')">\n      {{ \'tb.rulenode.max-delay-seconds-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <label translate class="tb-title">tb.rulenode.message-attributes</label>\n  <div class="tb-hint" translate>tb.rulenode.message-attributes-hint</div>\n  <tb-kv-map-config\n    required="false"\n    formControlName="messageAttributes"\n    keyText="tb.rulenode.name"\n    keyRequiredText="tb.rulenode.name-required"\n    valText="tb.rulenode.value"\n    valRequiredText="tb.rulenode.value-required">\n  </tb-kv-map-config>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-access-key-id</mat-label>\n    <input required matInput formControlName="accessKeyId">\n    <mat-error *ngIf="sqsConfigForm.get(\'accessKeyId\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-access-key-id-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-secret-access-key</mat-label>\n    <input required matInput formControlName="secretAccessKey">\n    <mat-error *ngIf="sqsConfigForm.get(\'secretAccessKey\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-secret-access-key-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.aws-region</mat-label>\n    <input required matInput formControlName="region">\n    <mat-error *ngIf="sqsConfigForm.get(\'region\').hasError(\'required\')">\n      {{ \'tb.rulenode.aws-region-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ne=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.pubSubConfigForm},r.prototype.onConfigurationSet=function(e){this.pubSubConfigForm=this.fb.group({projectId:[e?e.projectId:null,[i.Validators.required]],topicName:[e?e.topicName:null,[i.Validators.required]],serviceAccountKey:[e?e.serviceAccountKey:null,[i.Validators.required]],serviceAccountKeyFileName:[e?e.serviceAccountKeyFileName:null,[i.Validators.required]],messageAttributes:[e?e.messageAttributes:null,[]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-pub-sub-config",template:'<section [formGroup]="pubSubConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.gcp-project-id</mat-label>\n    <input required matInput formControlName="projectId">\n    <mat-error *ngIf="pubSubConfigForm.get(\'projectId\').hasError(\'required\')">\n      {{ \'tb.rulenode.gcp-project-id-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.pubsub-topic-name</mat-label>\n    <input required matInput formControlName="topicName">\n    <mat-error *ngIf="pubSubConfigForm.get(\'topicName\').hasError(\'required\')">\n      {{ \'tb.rulenode.pubsub-topic-name-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <tb-file-input style="padding-bottom: 24px;"\n                 formControlName="serviceAccountKey"\n                 [existingFileName]="pubSubConfigForm.get(\'serviceAccountKeyFileName\').value"\n                 (fileNameChanged)="pubSubConfigForm.get(\'serviceAccountKeyFileName\').setValue($event)"\n                 required\n                 requiredAsError\n                 label="{{\'tb.rulenode.gcp-service-account-key\' | translate}}"\n                 noFileText="tb.rulenode.no-file"\n                 dropLabel="{{\'tb.rulenode.drop-file\' | translate}}">\n  </tb-file-input>\n  <label translate class="tb-title">tb.rulenode.message-attributes</label>\n  <div class="tb-hint" translate>tb.rulenode.message-attributes-hint</div>\n  <tb-kv-map-config\n    required="false"\n    formControlName="messageAttributes"\n    keyText="tb.rulenode.name"\n    keyRequiredText="tb.rulenode.name-required"\n    valText="tb.rulenode.value"\n    valRequiredText="tb.rulenode.value-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ae=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.ackValues=["all","-1","0","1"],n}return g(r,e),r.prototype.configForm=function(){return this.kafkaConfigForm},r.prototype.onConfigurationSet=function(e){this.kafkaConfigForm=this.fb.group({topicPattern:[e?e.topicPattern:null,[i.Validators.required]],bootstrapServers:[e?e.bootstrapServers:null,[i.Validators.required]],retries:[e?e.retries:null,[i.Validators.min(0)]],batchSize:[e?e.batchSize:null,[i.Validators.min(0)]],linger:[e?e.linger:null,[i.Validators.min(0)]],bufferMemory:[e?e.bufferMemory:null,[i.Validators.min(0)]],acks:[e?e.acks:null,[i.Validators.required]],keySerializer:[e?e.keySerializer:null,[i.Validators.required]],valueSerializer:[e?e.valueSerializer:null,[i.Validators.required]],otherProperties:[e?e.otherProperties:null,[]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-kafka-config",template:'<section [formGroup]="kafkaConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.topic-pattern</mat-label>\n    <input required matInput formControlName="topicPattern">\n    <mat-error *ngIf="kafkaConfigForm.get(\'topicPattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.topic-pattern-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.bootstrap-servers</mat-label>\n    <input required matInput formControlName="bootstrapServers">\n    <mat-error *ngIf="kafkaConfigForm.get(\'bootstrapServers\').hasError(\'required\')">\n      {{ \'tb.rulenode.bootstrap-servers-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.retries</mat-label>\n    <input type="number" step="1" min="0" matInput formControlName="retries">\n    <mat-error *ngIf="kafkaConfigForm.get(\'retries\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-retries-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.batch-size-bytes</mat-label>\n    <input type="number" step="1" min="0" matInput formControlName="batchSize">\n    <mat-error *ngIf="kafkaConfigForm.get(\'batchSize\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-batch-size-bytes-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.linger-ms</mat-label>\n    <input type="number" step="1" min="0" matInput formControlName="linger">\n    <mat-error *ngIf="kafkaConfigForm.get(\'linger\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-linger-ms-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.buffer-memory-bytes</mat-label>\n    <input type="number" step="1" min="0" matInput formControlName="bufferMemory">\n    <mat-error *ngIf="kafkaConfigForm.get(\'bufferMemory\').hasError(\'min\')">\n      {{ \'tb.rulenode.min-buffer-memory-bytes-message\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.acks</mat-label>\n    <mat-select formControlName="acks" required>\n      <mat-option *ngFor="let ackValue of ackValues" [value]="ackValue">\n        {{ ackValue }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.key-serializer</mat-label>\n    <input required matInput formControlName="keySerializer">\n    <mat-error *ngIf="kafkaConfigForm.get(\'keySerializer\').hasError(\'required\')">\n      {{ \'tb.rulenode.key-serializer-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.value-serializer</mat-label>\n    <input required matInput formControlName="valueSerializer">\n    <mat-error *ngIf="kafkaConfigForm.get(\'valueSerializer\').hasError(\'required\')">\n      {{ \'tb.rulenode.value-serializer-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <label translate class="tb-title">tb.rulenode.other-properties</label>\n  <tb-kv-map-config\n    required="false"\n    formControlName="otherProperties"\n    keyText="tb.rulenode.key"\n    keyRequiredText="tb.rulenode.key-required"\n    valText="tb.rulenode.value"\n    valRequiredText="tb.rulenode.value-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var oe=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.allMqttCredentialsTypes=B,n.mqttCredentialsTypeTranslationsMap=H,n}return g(r,e),r.prototype.configForm=function(){return this.mqttConfigForm},r.prototype.onConfigurationSet=function(e){this.mqttConfigForm=this.fb.group({topicPattern:[e?e.topicPattern:null,[i.Validators.required]],host:[e?e.host:null,[i.Validators.required]],port:[e?e.port:null,[i.Validators.required,i.Validators.min(1),i.Validators.max(65535)]],connectTimeoutSec:[e?e.connectTimeoutSec:null,[i.Validators.required,i.Validators.min(1),i.Validators.max(200)]],clientId:[e?e.clientId:null,[]],cleanSession:[!!e&&e.cleanSession,[]],ssl:[!!e&&e.ssl,[]],credentials:this.fb.group({type:[e&&e.credentials?e.credentials.type:null,[i.Validators.required]],username:[e&&e.credentials?e.credentials.username:null,[]],password:[e&&e.credentials?e.credentials.password:null,[]],caCert:[e&&e.credentials?e.credentials.caCert:null,[]],caCertFileName:[e&&e.credentials?e.credentials.caCertFileName:null,[]],privateKey:[e&&e.credentials?e.credentials.privateKey:null,[]],privateKeyFileName:[e&&e.credentials?e.credentials.privateKeyFileName:null,[]],cert:[e&&e.credentials?e.credentials.cert:null,[]],certFileName:[e&&e.credentials?e.credentials.certFileName:null,[]]})})},r.prototype.prepareOutputConfig=function(e){var t=e.credentials.type;switch(t){case"anonymous":e.credentials={type:t};break;case"basic":e.credentials={type:t,username:e.credentials.username,password:e.credentials.password};break;case"cert.PEM":delete e.credentials.username}return e},r.prototype.validatorTriggers=function(){return["credentials.type"]},r.prototype.updateValidators=function(e){var t=this.mqttConfigForm.get("credentials"),r=t.get("type").value;switch(e&&t.reset({type:r},{emitEvent:!1}),t.get("username").setValidators([]),t.get("password").setValidators([]),t.get("caCert").setValidators([]),t.get("caCertFileName").setValidators([]),t.get("privateKey").setValidators([]),t.get("privateKeyFileName").setValidators([]),t.get("cert").setValidators([]),t.get("certFileName").setValidators([]),r){case"anonymous":break;case"basic":t.get("username").setValidators([i.Validators.required]),t.get("password").setValidators([i.Validators.required]);break;case"cert.PEM":t.get("caCert").setValidators([i.Validators.required]),t.get("caCertFileName").setValidators([i.Validators.required]),t.get("privateKey").setValidators([i.Validators.required]),t.get("privateKeyFileName").setValidators([i.Validators.required]),t.get("cert").setValidators([i.Validators.required]),t.get("certFileName").setValidators([i.Validators.required])}t.get("username").updateValueAndValidity({emitEvent:e}),t.get("password").updateValueAndValidity({emitEvent:e}),t.get("caCert").updateValueAndValidity({emitEvent:e}),t.get("caCertFileName").updateValueAndValidity({emitEvent:e}),t.get("privateKey").updateValueAndValidity({emitEvent:e}),t.get("privateKeyFileName").updateValueAndValidity({emitEvent:e}),t.get("cert").updateValueAndValidity({emitEvent:e}),t.get("certFileName").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-action-node-mqtt-config",template:'<section [formGroup]="mqttConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.topic-pattern</mat-label>\n    <input required matInput formControlName="topicPattern">\n    <mat-error *ngIf="mqttConfigForm.get(\'topicPattern\').hasError(\'required\')">\n      {{ \'tb.rulenode.topic-pattern-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.mqtt-topic-pattern-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <div fxFlex fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n    <mat-form-field fxFlex="60" class="mat-block">\n      <mat-label translate>tb.rulenode.host</mat-label>\n      <input required matInput formControlName="host">\n      <mat-error *ngIf="mqttConfigForm.get(\'host\').hasError(\'required\')">\n        {{ \'tb.rulenode.host-required\' | translate }}\n      </mat-error>\n    </mat-form-field>\n    <mat-form-field fxFlex="40" class="mat-block">\n      <mat-label translate>tb.rulenode.port</mat-label>\n      <input required type="number" step="1" min="1" max="65535" matInput formControlName="port">\n      <mat-error *ngIf="mqttConfigForm.get(\'port\').hasError(\'required\')">\n        {{ \'tb.rulenode.port-required\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="mqttConfigForm.get(\'port\').hasError(\'min\')">\n        {{ \'tb.rulenode.port-range\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="mqttConfigForm.get(\'port\').hasError(\'max\')">\n        {{ \'tb.rulenode.port-range\' | translate }}\n      </mat-error>\n    </mat-form-field>\n    <mat-form-field fxFlex="40" class="mat-block">\n      <mat-label translate>tb.rulenode.connect-timeout</mat-label>\n      <input required type="number" step="1" min="1" max="200" matInput formControlName="connectTimeoutSec">\n      <mat-error *ngIf="mqttConfigForm.get(\'connectTimeoutSec\').hasError(\'required\')">\n        {{ \'tb.rulenode.connect-timeout-required\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="mqttConfigForm.get(\'connectTimeoutSec\').hasError(\'min\')">\n        {{ \'tb.rulenode.connect-timeout-range\' | translate }}\n      </mat-error>\n      <mat-error *ngIf="mqttConfigForm.get(\'connectTimeoutSec\').hasError(\'max\')">\n        {{ \'tb.rulenode.connect-timeout-range\' | translate }}\n      </mat-error>\n    </mat-form-field>\n  </div>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.client-id</mat-label>\n    <input matInput formControlName="clientId">\n  </mat-form-field>\n  <mat-checkbox formControlName="cleanSession" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.clean-session\' | translate }}\n  </mat-checkbox>\n  <mat-checkbox formControlName="ssl" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.enable-ssl\' | translate }}\n  </mat-checkbox>\n  <mat-expansion-panel class="tb-mqtt-credentials-panel-group">\n    <mat-expansion-panel-header>\n      <mat-panel-title translate>tb.rulenode.credentials</mat-panel-title>\n      <mat-panel-description>\n        {{ mqttCredentialsTypeTranslationsMap.get(mqttConfigForm.get(\'credentials\').get(\'type\').value) | translate }}\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n    <section formGroupName="credentials" fxLayout="column">\n      <mat-form-field class="mat-block">\n        <mat-label translate>tb.rulenode.credentials-type</mat-label>\n        <mat-select formControlName="type" required>\n          <mat-option *ngFor="let credentialsType of allMqttCredentialsTypes" [value]="credentialsType">\n            {{ mqttCredentialsTypeTranslationsMap.get(credentialsType) | translate }}\n          </mat-option>\n        </mat-select>\n        <mat-error *ngIf="mqttConfigForm.get(\'credentials\').get(\'type\').hasError(\'required\')">\n          {{ \'tb.rulenode.credentials-type-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <section fxLayout="column" [ngSwitch]="mqttConfigForm.get(\'credentials\').get(\'type\').value">\n        <ng-template ngSwitchCase="anonymous">\n        </ng-template>\n        <ng-template ngSwitchCase="basic">\n          <mat-form-field class="mat-block">\n            <mat-label translate>tb.rulenode.username</mat-label>\n            <input required matInput formControlName="username">\n            <mat-error *ngIf="mqttConfigForm.get(\'credentials\').get(\'username\').hasError(\'required\')">\n              {{ \'tb.rulenode.username-required\' | translate }}\n            </mat-error>\n          </mat-form-field>\n          <mat-form-field class="mat-block">\n            <mat-label translate>tb.rulenode.password</mat-label>\n            <input type="password" required matInput formControlName="password">\n            <mat-error *ngIf="mqttConfigForm.get(\'credentials\').get(\'password\').hasError(\'required\')">\n              {{ \'tb.rulenode.password-required\' | translate }}\n            </mat-error>\n          </mat-form-field>\n        </ng-template>\n        <ng-template ngSwitchCase="cert.PEM">\n          <tb-file-input formControlName="caCert"\n                         inputId="caCertSelect"\n                         [existingFileName]="mqttConfigForm.get(\'credentials\').get(\'caCertFileName\').value"\n                         (fileNameChanged)="mqttConfigForm.get(\'credentials\').get(\'caCertFileName\').setValue($event)"\n                         required\n                         requiredAsError\n                         label="{{\'tb.rulenode.ca-cert\' | translate}}"\n                         noFileText="tb.rulenode.no-file"\n                         dropLabel="{{\'tb.rulenode.drop-file\' | translate}}">\n          </tb-file-input>\n          <tb-file-input formControlName="cert"\n                         inputId="CertSelect"\n                         [existingFileName]="mqttConfigForm.get(\'credentials\').get(\'certFileName\').value"\n                         (fileNameChanged)="mqttConfigForm.get(\'credentials\').get(\'certFileName\').setValue($event)"\n                         required\n                         requiredAsError\n                         label="{{\'tb.rulenode.cert\' | translate}}"\n                         noFileText="tb.rulenode.no-file"\n                         dropLabel="{{\'tb.rulenode.drop-file\' | translate}}">\n          </tb-file-input>\n          <tb-file-input style="padding-bottom: 8px;"\n                         formControlName="privateKey"\n                         inputId="privateKeySelect"\n                         [existingFileName]="mqttConfigForm.get(\'credentials\').get(\'privateKeyFileName\').value"\n                         (fileNameChanged)="mqttConfigForm.get(\'credentials\').get(\'privateKeyFileName\').setValue($event)"\n                         required\n                         requiredAsError\n                         label="{{\'tb.rulenode.private-key\' | translate}}"\n                         noFileText="tb.rulenode.no-file"\n                         dropLabel="{{\'tb.rulenode.drop-file\' | translate}}">\n          </tb-file-input>\n          <mat-form-field class="mat-block">\n            <mat-label translate>tb.rulenode.private-key-password</mat-label>\n            <input type="password" matInput formControlName="password">\n          </mat-form-field>\n        </ng-template>\n      </section>\n    </section>\n  </mat-expansion-panel>\n</section>\n',styles:[":host .tb-mqtt-credentials-panel-group{margin:0 6px}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ie=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{declarations:[h,C,v,F,T,q,x,I,N,k,S,$,Q,z,_,ee,te,re,ne,ae,oe],imports:[r.CommonModule,a.SharedModule,X],exports:[h,C,v,F,T,q,x,I,N,k,S,$,Q,z,_,ee,te,re,ne,ae,oe]}]}],e}(),le=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],n}return g(r,e),r.prototype.configForm=function(){return this.checkMessageConfigForm},r.prototype.onConfigurationSet=function(e){this.checkMessageConfigForm=this.fb.group({messageNames:[e?e.messageNames:null,[]],metadataNames:[e?e.metadataNames:null,[]],checkAllKeys:[!!e&&e.checkAllKeys,[]]})},r.prototype.validateConfig=function(){var e=this.checkMessageConfigForm.get("messageNames").value,t=this.checkMessageConfigForm.get("metadataNames").value;return e.length>0||t.length>0},r.prototype.removeMessageName=function(e){var t=this.checkMessageConfigForm.get("messageNames").value,r=t.indexOf(e);r>=0&&(t.splice(r,1),this.checkMessageConfigForm.get("messageNames").setValue(t,{emitEvent:!0}))},r.prototype.removeMetadataName=function(e){var t=this.checkMessageConfigForm.get("metadataNames").value,r=t.indexOf(e);r>=0&&(t.splice(r,1),this.checkMessageConfigForm.get("metadataNames").setValue(t,{emitEvent:!0}))},r.prototype.addMessageName=function(e){var t=e.input,r=e.value;if((r||"").trim()){r=r.trim();var n=this.checkMessageConfigForm.get("messageNames").value;n&&-1!==n.indexOf(r)||(n||(n=[]),n.push(r),this.checkMessageConfigForm.get("messageNames").setValue(n,{emitEvent:!0}))}t&&(t.value="")},r.prototype.addMetadataName=function(e){var t=e.input,r=e.value;if((r||"").trim()){r=r.trim();var n=this.checkMessageConfigForm.get("metadataNames").value;n&&-1!==n.indexOf(r)||(n||(n=[]),n.push(r),this.checkMessageConfigForm.get("metadataNames").setValue(n,{emitEvent:!0}))}t&&(t.value="")},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-check-message-config",template:'<section [formGroup]="checkMessageConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding tb-required">tb.rulenode.data-keys</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #messageNamesChipList>\n      <mat-chip\n        *ngFor="let messageName of checkMessageConfigForm.get(\'messageNames\').value;"\n        (removed)="removeMessageName(messageName)">\n        {{messageName}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.data-keys\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="messageNamesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addMessageName($event)"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <div class="tb-hint" translate>tb.rulenode.separator-hint</div>\n  <label translate class="tb-title no-padding tb-required">tb.rulenode.metadata-keys</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #metadataNamesChipList>\n      <mat-chip\n        *ngFor="let metadataName of checkMessageConfigForm.get(\'metadataNames\').value;"\n        (removed)="removeMetadataName(metadataName)">\n        {{metadataName}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.metadata-keys\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="metadataNamesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addMetadataName($event)"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <div class="tb-hint" translate>tb.rulenode.separator-hint</div>\n  <mat-checkbox fxFlex formControlName="checkAllKeys" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.check-all-keys\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" translate>tb.rulenode.check-all-keys-hint</div>\n</section>\n',styles:[":host label.tb-title{margin-bottom:-10px}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var se=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.entitySearchDirection=Object.keys(a.EntitySearchDirection),n.entitySearchDirectionTranslationsMap=a.entitySearchDirectionTranslations,n}return g(r,e),r.prototype.configForm=function(){return this.checkRelationConfigForm},r.prototype.onConfigurationSet=function(e){this.checkRelationConfigForm=this.fb.group({checkForSingleEntity:[!!e&&e.checkForSingleEntity,[]],direction:[e?e.direction:null,[]],entityType:[e?e.entityType:null,e&&e.checkForSingleEntity?[i.Validators.required]:[]],entityId:[e?e.entityId:null,e&&e.checkForSingleEntity?[i.Validators.required]:[]],relationType:[e?e.relationType:null,[i.Validators.required]]})},r.prototype.validatorTriggers=function(){return["checkForSingleEntity"]},r.prototype.updateValidators=function(e){var t=this.checkRelationConfigForm.get("checkForSingleEntity").value;this.checkRelationConfigForm.get("entityType").setValidators(t?[i.Validators.required]:[]),this.checkRelationConfigForm.get("entityType").updateValueAndValidity({emitEvent:e}),this.checkRelationConfigForm.get("entityId").setValidators(t?[i.Validators.required]:[]),this.checkRelationConfigForm.get("entityId").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-check-relation-config",template:'<section [formGroup]="checkRelationConfigForm" fxLayout="column">\n  <mat-checkbox fxFlex formControlName="checkForSingleEntity" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.check-relation-to-specific-entity\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" translate>tb.rulenode.check-relation-hint</div>\n  <mat-form-field class="mat-block" style="min-width: 100px;">\n    <mat-label translate>relation.direction</mat-label>\n    <mat-select formControlName="direction" required>\n      <mat-option *ngFor="let direction of entitySearchDirection" [value]="direction">\n        {{ entitySearchDirectionTranslationsMap.get(direction) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <div fxLayout="row" *ngIf="checkRelationConfigForm.get(\'checkForSingleEntity\').value" style="padding-top: 20px">\n    <tb-entity-type-select\n      style="min-width: 100px; padding-bottom: 20px; padding-right: 8px;"\n      showLabel\n      required\n      formControlName="entityType">\n    </tb-entity-type-select>\n    <tb-entity-autocomplete\n      fxFlex\n      required\n      *ngIf="checkRelationConfigForm.get(\'entityType\').value"\n      [entityType]="checkRelationConfigForm.get(\'entityType\').value"\n      formControlName="entityId">\n    </tb-entity-autocomplete>\n  </div>\n  <tb-relation-type-autocomplete\n    required\n    formControlName="relationType">\n  </tb-relation-type-autocomplete>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var me=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.perimeterType=A,n.perimeterTypes=Object.keys(A),n.perimeterTypeTranslationMap=L,n.rangeUnits=Object.keys(D),n.rangeUnitTranslationMap=P,n}return g(r,e),r.prototype.configForm=function(){return this.geoFilterConfigForm},r.prototype.onConfigurationSet=function(e){this.geoFilterConfigForm=this.fb.group({latitudeKeyName:[e?e.latitudeKeyName:null,[i.Validators.required]],longitudeKeyName:[e?e.longitudeKeyName:null,[i.Validators.required]],fetchPerimeterInfoFromMessageMetadata:[!!e&&e.fetchPerimeterInfoFromMessageMetadata,[]],perimeterType:[e?e.perimeterType:null,[]],centerLatitude:[e?e.centerLatitude:null,[]],centerLongitude:[e?e.centerLatitude:null,[]],range:[e?e.range:null,[]],rangeUnit:[e?e.rangeUnit:null,[]],polygonsDefinition:[e?e.polygonsDefinition:null,[]]})},r.prototype.validatorTriggers=function(){return["fetchPerimeterInfoFromMessageMetadata","perimeterType"]},r.prototype.updateValidators=function(e){var t=this.geoFilterConfigForm.get("fetchPerimeterInfoFromMessageMetadata").value,r=this.geoFilterConfigForm.get("perimeterType").value;t?this.geoFilterConfigForm.get("perimeterType").setValidators([]):this.geoFilterConfigForm.get("perimeterType").setValidators([i.Validators.required]),t||r!==A.CIRCLE?(this.geoFilterConfigForm.get("centerLatitude").setValidators([]),this.geoFilterConfigForm.get("centerLongitude").setValidators([]),this.geoFilterConfigForm.get("range").setValidators([]),this.geoFilterConfigForm.get("rangeUnit").setValidators([])):(this.geoFilterConfigForm.get("centerLatitude").setValidators([i.Validators.required,i.Validators.min(-90),i.Validators.max(90)]),this.geoFilterConfigForm.get("centerLongitude").setValidators([i.Validators.required,i.Validators.min(-180),i.Validators.max(180)]),this.geoFilterConfigForm.get("range").setValidators([i.Validators.required,i.Validators.min(0)]),this.geoFilterConfigForm.get("rangeUnit").setValidators([i.Validators.required])),t||r!==A.POLYGON?this.geoFilterConfigForm.get("polygonsDefinition").setValidators([]):this.geoFilterConfigForm.get("polygonsDefinition").setValidators([i.Validators.required]),this.geoFilterConfigForm.get("perimeterType").updateValueAndValidity({emitEvent:!1}),this.geoFilterConfigForm.get("centerLatitude").updateValueAndValidity({emitEvent:e}),this.geoFilterConfigForm.get("centerLongitude").updateValueAndValidity({emitEvent:e}),this.geoFilterConfigForm.get("range").updateValueAndValidity({emitEvent:e}),this.geoFilterConfigForm.get("rangeUnit").updateValueAndValidity({emitEvent:e}),this.geoFilterConfigForm.get("polygonsDefinition").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-gps-geofencing-config",template:'<section [formGroup]="geoFilterConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.latitude-key-name</mat-label>\n    <input matInput formControlName="latitudeKeyName" required>\n    <mat-error *ngIf="geoFilterConfigForm.get(\'latitudeKeyName\').hasError(\'required\')">\n      {{ \'tb.rulenode.latitude-key-name-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.longitude-key-name</mat-label>\n    <input matInput formControlName="longitudeKeyName" required>\n    <mat-error *ngIf="geoFilterConfigForm.get(\'longitudeKeyName\').hasError(\'required\')">\n      {{ \'tb.rulenode.longitude-key-name-required\' | translate }}\n    </mat-error>\n  </mat-form-field>\n  <mat-checkbox fxFlex formControlName="fetchPerimeterInfoFromMessageMetadata" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.fetch-perimeter-info-from-message-metadata\' | translate }}\n  </mat-checkbox>\n  <div fxLayout="row" *ngIf="!geoFilterConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <mat-form-field fxFlex class="mat-block">\n      <mat-label translate>tb.rulenode.perimeter-type</mat-label>\n      <mat-select formControlName="perimeterType" required>\n        <mat-option *ngFor="let type of perimeterTypes" [value]="type">\n          {{ perimeterTypeTranslationMap.get(type) | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n  <div fxLayout="column"\n       *ngIf="geoFilterConfigForm.get(\'perimeterType\').value === perimeterType.CIRCLE &&\n       !geoFilterConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <div fxLayout="row" fxLayoutGap="8px">\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.circle-center-latitude</mat-label>\n        <input type="number" min="-90" max="90" step="0.1" matInput formControlName="centerLatitude" required>\n        <mat-error *ngIf="geoFilterConfigForm.get(\'centerLatitude\').hasError(\'required\')">\n          {{ \'tb.rulenode.circle-center-latitude-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.circle-center-longitude</mat-label>\n        <input type="number" min="-180" max="180" step="0.1" matInput formControlName="centerLongitude" required>\n        <mat-error *ngIf="geoFilterConfigForm.get(\'centerLongitude\').hasError(\'required\')">\n          {{ \'tb.rulenode.circle-center-longitude-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n    </div>\n    <div fxLayout="row" fxLayoutGap="8px">\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.range</mat-label>\n        <input type="number" min="0" step="0.1" matInput formControlName="range" required>\n        <mat-error *ngIf="geoFilterConfigForm.get(\'range\').hasError(\'required\')">\n          {{ \'tb.rulenode.range-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex>\n        <mat-label translate>tb.rulenode.range-units</mat-label>\n        <mat-select formControlName="rangeUnit" required>\n          <mat-option *ngFor="let type of rangeUnits" [value]="type">\n            {{ rangeUnitTranslationMap.get(type) | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n  <div fxLayout="row" *ngIf="geoFilterConfigForm.get(\'perimeterType\').value === perimeterType.POLYGON &&\n                             !geoFilterConfigForm.get(\'fetchPerimeterInfoFromMessageMetadata\').value">\n    <div fxLayout="column" fxFlex="100">\n      <mat-form-field class="mat-block" hintLabel="{{\'tb.rulenode.polygon-definition-hint\' | translate}}">\n        <mat-label translate>tb.rulenode.polygon-definition</mat-label>\n        <input matInput formControlName="polygonsDefinition" required>\n        <mat-error *ngIf="geoFilterConfigForm.get(\'polygonsDefinition\').hasError(\'required\')">\n          {{ \'tb.rulenode.polygon-definition-required\' | translate }}\n        </mat-error>\n      </mat-form-field>\n    </div>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ue=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.messageTypeConfigForm},r.prototype.onConfigurationSet=function(e){this.messageTypeConfigForm=this.fb.group({messageTypes:[e?e.messageTypes:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-message-type-config",template:'<section [formGroup]="messageTypeConfigForm" fxLayout="column">\n  <tb-message-types-config\n    required\n    label="tb.rulenode.message-types-filter"\n    formControlName="messageTypes"\n  ></tb-message-types-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var de=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.allowedEntityTypes=[a.EntityType.DEVICE,a.EntityType.ASSET,a.EntityType.ENTITY_VIEW,a.EntityType.TENANT,a.EntityType.CUSTOMER,a.EntityType.USER,a.EntityType.DASHBOARD,a.EntityType.RULE_CHAIN,a.EntityType.RULE_NODE],n}return g(r,e),r.prototype.configForm=function(){return this.originatorTypeConfigForm},r.prototype.onConfigurationSet=function(e){this.originatorTypeConfigForm=this.fb.group({originatorTypes:[e?e.originatorTypes:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-originator-type-config",template:'<section [formGroup]="originatorTypeConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding tb-required">tb.rulenode.originator-types-filter</label>\n  <tb-entity-type-list fxFlex\n                       formControlName="originatorTypes"\n                       [allowedEntityTypes]="allowedEntityTypes"\n                       [ignoreAuthorityFilter]="true"\n                       required>\n  </tb-entity-type-list>\n</section>\n',styles:[":host ::ng-deep tb-entity-type-list .mat-form-field-flex{padding-top:0}:host ::ng-deep tb-entity-type-list .mat-form-field-infix{border-top:0}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var pe=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.scriptConfigForm},r.prototype.onConfigurationSet=function(e){this.scriptConfigForm=this.fb.group({jsScript:[e?e.jsScript:null,[i.Validators.required]]})},r.prototype.testScript=function(){var e=this,t=this.scriptConfigForm.get("jsScript").value;this.nodeScriptTestService.testNodeScript(t,"filter",this.translate.instant("tb.rulenode.filter"),"Filter",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.scriptConfigForm.get("jsScript").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-script-config",template:'<section [formGroup]="scriptConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.filter</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="jsScript"\n              functionName="Filter"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-filter-function\' | translate }}\n    </button>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var ce=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.switchConfigForm},r.prototype.onConfigurationSet=function(e){this.switchConfigForm=this.fb.group({jsScript:[e?e.jsScript:null,[i.Validators.required]]})},r.prototype.testScript=function(){var e=this,t=this.switchConfigForm.get("jsScript").value;this.nodeScriptTestService.testNodeScript(t,"switch",this.translate.instant("tb.rulenode.switch"),"Switch",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.switchConfigForm.get("jsScript").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-filter-node-switch-config",template:'<section [formGroup]="switchConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.switch</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="jsScript"\n              functionName="Switch"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-switch-function\' | translate }}\n    </button>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var fe=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{declarations:[le,se,me,ue,de,pe,ce],imports:[r.CommonModule,a.SharedModule,X],exports:[le,se,me,ue,de,pe,ce]}]}],e}(),ge=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.customerAttributesConfigForm},r.prototype.onConfigurationSet=function(e){this.customerAttributesConfigForm=this.fb.group({telemetry:[!!e&&e.telemetry,[]],attrMapping:[e?e.attrMapping:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-customer-attributes-config",template:'<section [formGroup]="customerAttributesConfigForm" fxLayout="column">\n  <label translate class="tb-title tb-required">tb.rulenode.attr-mapping</label>\n  <mat-checkbox fxFlex formControlName="telemetry" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.latest-telemetry\' | translate }}\n  </mat-checkbox>\n  <tb-kv-map-config\n    required\n    formControlName="attrMapping"\n    requiredText="tb.rulenode.attr-mapping-required"\n    keyText="{{ customerAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry\' : \'tb.rulenode.source-attribute\' }}"\n    keyRequiredText="{{ customerAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry-required\' : \'tb.rulenode.source-attribute-required\' }}"\n    valText="tb.rulenode.target-attribute"\n    valRequiredText="tb.rulenode.target-attribute-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ye=function(e){function r(t,r,n){var a,o,i=e.call(this,t)||this;i.store=t,i.translate=r,i.fb=n,i.entityDetailsTranslationsMap=O,i.entityDetailsList=[],i.searchText="",i.displayDetailsFn=i.displayDetails.bind(i);try{for(var l=y(Object.keys(w)),s=l.next();!s.done;s=l.next()){var m=s.value;i.entityDetailsList.push(w[m])}}catch(e){a={error:e}}finally{try{s&&!s.done&&(o=l.return)&&o.call(l)}finally{if(a)throw a.error}}return i}return g(r,e),r.prototype.ngOnInit=function(){var t=this;this.detailsFormControl=new i.FormControl(""),e.prototype.ngOnInit.call(this),this.filteredEntityDetails=this.detailsFormControl.valueChanges.pipe(c.startWith(""),c.map((function(e){return e||""})),c.mergeMap((function(e){return t.fetchEntityDetails(e)})),c.share())},r.prototype.configForm=function(){return this.entityDetailsConfigForm},r.prototype.prepareInputConfig=function(e){return this.searchText="",this.detailsFormControl.patchValue("",{emitEvent:!0}),e},r.prototype.onConfigurationSet=function(e){this.entityDetailsConfigForm=this.fb.group({detailsList:[e?e.detailsList:null,[i.Validators.required]],addToMetadata:[!!e&&e.addToMetadata,[]]})},r.prototype.displayDetails=function(e){return e?this.translate.instant(O.get(e)):void 0},r.prototype.fetchEntityDetails=function(e){var t=this;if(this.searchText=e,this.searchText&&this.searchText.length){var r=this.searchText.toUpperCase();return p.of(this.entityDetailsList.filter((function(e){return t.translate.instant(O.get(w[e])).toUpperCase().includes(r)})))}return p.of(this.entityDetailsList)},r.prototype.detailsFieldSelected=function(e){this.addDetailsField(e.option.value),this.clear("")},r.prototype.removeDetailsField=function(e){var t=this.entityDetailsConfigForm.get("detailsList").value;if(t){var r=t.indexOf(e);r>=0&&(t.splice(r,1),this.entityDetailsConfigForm.get("detailsList").setValue(t))}},r.prototype.addDetailsField=function(e){var t=this.entityDetailsConfigForm.get("detailsList").value;t||(t=[]),-1===t.indexOf(e)&&(t.push(e),this.entityDetailsConfigForm.get("detailsList").setValue(t))},r.prototype.clear=function(e){var t=this;void 0===e&&(e=""),this.detailsInput.nativeElement.value=e,this.detailsFormControl.patchValue(null,{emitEvent:!0}),setTimeout((function(){t.detailsInput.nativeElement.blur(),t.detailsInput.nativeElement.focus()}),0)},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-entity-details-config",template:'<section [formGroup]="entityDetailsConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding tb-required">tb.rulenode.entity-details</label>\n  <mat-form-field floatLabel="always" class="mat-block" class="entity-fields-list">\n    <mat-chip-list #detailsChipList>\n      <mat-chip\n        *ngFor="let details of entityDetailsConfigForm.get(\'detailsList\').value;"\n        (removed)="removeDetailsField(details)">\n        <span>\n          <strong>{{entityDetailsTranslationsMap.get(details) | translate}}</strong>\n        </span>\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text"\n             style="max-width: 200px;"\n             #detailsInput\n             [formControl]="detailsFormControl"\n             matAutocompleteOrigin\n             #origin="matAutocompleteOrigin"\n             [matAutocompleteConnectedTo]="origin"\n             [matAutocomplete]="detailsAutocomplete"\n             [matChipInputFor]="detailsChipList">\n    </mat-chip-list>\n    <mat-autocomplete #detailsAutocomplete="matAutocomplete"\n                      class="tb-autocomplete"\n                      (optionSelected)="detailsFieldSelected($event)"\n                      [displayWith]="displayDetailsFn">\n      <mat-option *ngFor="let details of filteredEntityDetails | async" [value]="details">\n        <span [innerHTML]="entityDetailsTranslationsMap.get(details) | translate | highlight:searchText"></span>\n      </mat-option>\n      <mat-option *ngIf="(filteredEntityDetails | async)?.length === 0" [value]="null" class="tb-not-found">\n        <div class="tb-not-found-content" (click)="$event.stopPropagation()">\n          <div>\n            <span translate>tb.rulenode.no-entity-details-matching</span>\n          </div>\n        </div>\n      </mat-option>\n    </mat-autocomplete>\n  </mat-form-field>\n  <tb-error [error]="(detailsFormControl.touched &&\n                     entityDetailsConfigForm.get(\'detailsList\').hasError(\'required\'))\n                  ? translate.instant(\'tb.rulenode.entity-details-list-empty\') : \'\'"></tb-error>\n  <mat-checkbox fxFlex formControlName="addToMetadata" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.add-to-metadata\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" translate>tb.rulenode.add-to-metadata-hint</div>\n</section>\n',styles:[":host ::ng-deep mat-form-field.entity-fields-list .mat-form-field-wrapper{margin-bottom:-1.25em}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:n.TranslateService},{type:i.FormBuilder}]},r.propDecorators={detailsInput:[{type:t.ViewChild,args:["detailsInput",{static:!1}]}]},r}(a.RuleNodeConfigurationComponent);var be=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],n}return g(r,e),r.prototype.configForm=function(){return this.deviceAttributesConfigForm},r.prototype.onConfigurationSet=function(e){this.deviceAttributesConfigForm=this.fb.group({deviceRelationsQuery:[e?e.deviceRelationsQuery:null,[i.Validators.required]],tellFailureIfAbsent:[!!e&&e.tellFailureIfAbsent,[]],clientAttributeNames:[e?e.clientAttributeNames:null,[]],sharedAttributeNames:[e?e.sharedAttributeNames:null,[]],serverAttributeNames:[e?e.serverAttributeNames:null,[]],latestTsKeyNames:[e?e.latestTsKeyNames:null,[]],getLatestValueWithTs:[!!e&&e.getLatestValueWithTs,[]]})},r.prototype.removeKey=function(e,t){var r=this.deviceAttributesConfigForm.get(t).value,n=r.indexOf(e);n>=0&&(r.splice(n,1),this.deviceAttributesConfigForm.get(t).setValue(r,{emitEvent:!0}))},r.prototype.addKey=function(e,t){var r=e.input,n=e.value;if((n||"").trim()){n=n.trim();var a=this.deviceAttributesConfigForm.get(t).value;a&&-1!==a.indexOf(n)||(a||(a=[]),a.push(n),this.deviceAttributesConfigForm.get(t).setValue(a,{emitEvent:!0}))}r&&(r.value="")},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-device-attributes-config",template:'<section [formGroup]="deviceAttributesConfigForm" fxLayout="column">\n  <label translate class="tb-title tb-required">tb.rulenode.device-relations-query</label>\n  <tb-device-relations-query-config\n    required\n    formControlName="deviceRelationsQuery"\n    style="padding-bottom: 15px;">\n  </tb-device-relations-query-config>\n  <mat-checkbox fxFlex formControlName="tellFailureIfAbsent" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.tell-failure-if-absent\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" translate>tb.rulenode.tell-failure-if-absent-hint</div>\n  <label translate class="tb-title no-padding">tb.rulenode.client-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #clientAttributesChipList>\n      <mat-chip\n        *ngFor="let key of deviceAttributesConfigForm.get(\'clientAttributeNames\').value;"\n        (removed)="removeKey(key, \'clientAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.client-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="clientAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'clientAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.shared-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #sharedAttributesChipList>\n      <mat-chip\n        *ngFor="let key of deviceAttributesConfigForm.get(\'sharedAttributeNames\').value;"\n        (removed)="removeKey(key, \'sharedAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.shared-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="sharedAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'sharedAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.server-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #serverAttributesChipList>\n      <mat-chip\n        *ngFor="let key of deviceAttributesConfigForm.get(\'serverAttributeNames\').value;"\n        (removed)="removeKey(key, \'serverAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.server-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="serverAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'serverAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.latest-timeseries</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #latestTimeseriesChipList>\n      <mat-chip\n        *ngFor="let key of deviceAttributesConfigForm.get(\'latestTsKeyNames\').value;"\n        (removed)="removeKey(key, \'latestTsKeyNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.latest-timeseries\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="latestTimeseriesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'latestTsKeyNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <mat-checkbox formControlName="getLatestValueWithTs" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.get-latest-value-with-ts\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" innerHTML="{{ \'tb.rulenode.get-latest-value-with-ts-hint\' | translate }}"></div>\n</section>\n',styles:[":host label.tb-title{margin-bottom:-10px}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var he=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],n}return g(r,e),r.prototype.configForm=function(){return this.originatorAttributesConfigForm},r.prototype.onConfigurationSet=function(e){this.originatorAttributesConfigForm=this.fb.group({tellFailureIfAbsent:[!!e&&e.tellFailureIfAbsent,[]],clientAttributeNames:[e?e.clientAttributeNames:null,[]],sharedAttributeNames:[e?e.sharedAttributeNames:null,[]],serverAttributeNames:[e?e.serverAttributeNames:null,[]],latestTsKeyNames:[e?e.latestTsKeyNames:null,[]],getLatestValueWithTs:[!!e&&e.getLatestValueWithTs,[]]})},r.prototype.removeKey=function(e,t){var r=this.originatorAttributesConfigForm.get(t).value,n=r.indexOf(e);n>=0&&(r.splice(n,1),this.originatorAttributesConfigForm.get(t).setValue(r,{emitEvent:!0}))},r.prototype.addKey=function(e,t){var r=e.input,n=e.value;if((n||"").trim()){n=n.trim();var a=this.originatorAttributesConfigForm.get(t).value;a&&-1!==a.indexOf(n)||(a||(a=[]),a.push(n),this.originatorAttributesConfigForm.get(t).setValue(a,{emitEvent:!0}))}r&&(r.value="")},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-originator-attributes-config",template:'<section [formGroup]="originatorAttributesConfigForm" fxLayout="column">\n  <mat-checkbox fxFlex formControlName="tellFailureIfAbsent" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.tell-failure-if-absent\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" translate>tb.rulenode.tell-failure-if-absent-hint</div>\n  <label translate class="tb-title no-padding">tb.rulenode.client-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #clientAttributesChipList>\n      <mat-chip\n        *ngFor="let key of originatorAttributesConfigForm.get(\'clientAttributeNames\').value;"\n        (removed)="removeKey(key, \'clientAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.client-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="clientAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'clientAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.shared-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #sharedAttributesChipList>\n      <mat-chip\n        *ngFor="let key of originatorAttributesConfigForm.get(\'sharedAttributeNames\').value;"\n        (removed)="removeKey(key, \'sharedAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.shared-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="sharedAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'sharedAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.server-attributes</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #serverAttributesChipList>\n      <mat-chip\n        *ngFor="let key of originatorAttributesConfigForm.get(\'serverAttributeNames\').value;"\n        (removed)="removeKey(key, \'serverAttributeNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.server-attributes\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="serverAttributesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'serverAttributeNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <label translate class="tb-title no-padding">tb.rulenode.latest-timeseries</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #latestTimeseriesChipList>\n      <mat-chip\n        *ngFor="let key of originatorAttributesConfigForm.get(\'latestTsKeyNames\').value;"\n        (removed)="removeKey(key, \'latestTsKeyNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.latest-timeseries\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="latestTimeseriesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'latestTsKeyNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <mat-checkbox formControlName="getLatestValueWithTs" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.get-latest-value-with-ts\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" innerHTML="{{ \'tb.rulenode.get-latest-value-with-ts-hint\' | translate }}"></div>\n</section>\n',styles:[":host label.tb-title{margin-bottom:-10px}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var Ce=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.originatorFieldsConfigForm},r.prototype.onConfigurationSet=function(e){this.originatorFieldsConfigForm=this.fb.group({fieldsMapping:[e?e.fieldsMapping:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-originator-fields-config",template:'<section [formGroup]="originatorFieldsConfigForm" fxLayout="column">\n  <label translate class="tb-title tb-required">tb.rulenode.fields-mapping</label>\n  <tb-kv-map-config\n    required\n    formControlName="fieldsMapping"\n    requiredText="tb.rulenode.fields-mapping-required"\n    keyText="tb.rulenode.source-field"\n    keyRequiredText="tb.rulenode.source-field-required"\n    valText="tb.rulenode.target-attribute"\n    valRequiredText="tb.rulenode.target-attribute-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ve=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.separatorKeysCodes=[s.ENTER,s.COMMA,s.SEMICOLON],n.fetchMode=K,n.fetchModes=Object.keys(K),n.samplingOrders=Object.keys(j),n.timeUnits=Object.keys(M),n.timeUnitsTranslationMap=R,n}return g(r,e),r.prototype.configForm=function(){return this.getTelemetryFromDatabaseConfigForm},r.prototype.onConfigurationSet=function(e){this.getTelemetryFromDatabaseConfigForm=this.fb.group({latestTsKeyNames:[e?e.latestTsKeyNames:null,[]],fetchMode:[e?e.fetchMode:null,[i.Validators.required]],orderBy:[e?e.orderBy:null,[]],limit:[e?e.limit:null,[]],useMetadataIntervalPatterns:[!!e&&e.useMetadataIntervalPatterns,[]],startInterval:[e?e.startInterval:null,[]],startIntervalTimeUnit:[e?e.startIntervalTimeUnit:null,[]],endInterval:[e?e.endInterval:null,[]],endIntervalTimeUnit:[e?e.endIntervalTimeUnit:null,[]],startIntervalPattern:[e?e.startIntervalPattern:null,[]],endIntervalPattern:[e?e.endIntervalPattern:null,[]]})},r.prototype.validatorTriggers=function(){return["fetchMode","useMetadataIntervalPatterns"]},r.prototype.updateValidators=function(e){var t=this.getTelemetryFromDatabaseConfigForm.get("fetchMode").value,r=this.getTelemetryFromDatabaseConfigForm.get("useMetadataIntervalPatterns").value;t&&t===K.ALL?(this.getTelemetryFromDatabaseConfigForm.get("orderBy").setValidators([i.Validators.required]),this.getTelemetryFromDatabaseConfigForm.get("limit").setValidators([i.Validators.required,i.Validators.min(2),i.Validators.max(1e3)])):(this.getTelemetryFromDatabaseConfigForm.get("orderBy").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("limit").setValidators([])),r?(this.getTelemetryFromDatabaseConfigForm.get("startInterval").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("startIntervalTimeUnit").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("endInterval").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("endIntervalTimeUnit").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("startIntervalPattern").setValidators([i.Validators.required]),this.getTelemetryFromDatabaseConfigForm.get("endIntervalPattern").setValidators([i.Validators.required])):(this.getTelemetryFromDatabaseConfigForm.get("startInterval").setValidators([i.Validators.required,i.Validators.min(1),i.Validators.max(2147483647)]),this.getTelemetryFromDatabaseConfigForm.get("startIntervalTimeUnit").setValidators([i.Validators.required]),this.getTelemetryFromDatabaseConfigForm.get("endInterval").setValidators([i.Validators.required,i.Validators.min(1),i.Validators.max(2147483647)]),this.getTelemetryFromDatabaseConfigForm.get("endIntervalTimeUnit").setValidators([i.Validators.required]),this.getTelemetryFromDatabaseConfigForm.get("startIntervalPattern").setValidators([]),this.getTelemetryFromDatabaseConfigForm.get("endIntervalPattern").setValidators([])),this.getTelemetryFromDatabaseConfigForm.get("orderBy").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("limit").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("startInterval").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("startIntervalTimeUnit").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("endInterval").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("endIntervalTimeUnit").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("startIntervalPattern").updateValueAndValidity({emitEvent:e}),this.getTelemetryFromDatabaseConfigForm.get("endIntervalPattern").updateValueAndValidity({emitEvent:e})},r.prototype.removeKey=function(e,t){var r=this.getTelemetryFromDatabaseConfigForm.get(t).value,n=r.indexOf(e);n>=0&&(r.splice(n,1),this.getTelemetryFromDatabaseConfigForm.get(t).setValue(r,{emitEvent:!0}))},r.prototype.addKey=function(e,t){var r=e.input,n=e.value;if((n||"").trim()){n=n.trim();var a=this.getTelemetryFromDatabaseConfigForm.get(t).value;a&&-1!==a.indexOf(n)||(a||(a=[]),a.push(n),this.getTelemetryFromDatabaseConfigForm.get(t).setValue(a,{emitEvent:!0}))}r&&(r.value="")},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-get-telemetry-from-database",template:'<section [formGroup]="getTelemetryFromDatabaseConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.latest-timeseries</label>\n  <mat-form-field floatLabel="always" class="mat-block">\n    <mat-label></mat-label>\n    <mat-chip-list #latestTimeseriesChipList>\n      <mat-chip\n        *ngFor="let key of getTelemetryFromDatabaseConfigForm.get(\'latestTsKeyNames\').value;"\n        (removed)="removeKey(key, \'latestTsKeyNames\')">\n        {{key}}\n        <mat-icon matChipRemove>close</mat-icon>\n      </mat-chip>\n      <input matInput type="text" placeholder="{{\'tb.rulenode.latest-timeseries\' | translate}}"\n             style="max-width: 200px;"\n             [matChipInputFor]="latestTimeseriesChipList"\n             [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n             (matChipInputTokenEnd)="addKey($event, \'latestTsKeyNames\')"\n             [matChipInputAddOnBlur]="true">\n    </mat-chip-list>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.fetch-mode</mat-label>\n    <mat-select formControlName="fetchMode" required>\n      <mat-option *ngFor="let mode of fetchModes" [value]="mode">\n        {{ mode }}\n      </mat-option>\n    </mat-select>\n    <mat-hint translate>tb.rulenode.fetch-mode-hint</mat-hint>\n  </mat-form-field>\n  <div fxLayout="column" *ngIf="getTelemetryFromDatabaseConfigForm.get(\'fetchMode\').value === fetchMode.ALL">\n    <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.order-by</mat-label>\n      <mat-select formControlName="orderBy" required>\n        <mat-option *ngFor="let order of samplingOrders" [value]="order">\n          {{ order }}\n        </mat-option>\n      </mat-select>\n      <mat-hint translate>tb.rulenode.order-by-hint</mat-hint>\n    </mat-form-field>\n    <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.limit</mat-label>\n      <input type="number" min="2" max="1000" step="1" matInput formControlName="limit" required>\n      <mat-hint translate>tb.rulenode.limit-hint</mat-hint>\n    </mat-form-field>\n  </div>\n  <mat-checkbox formControlName="useMetadataIntervalPatterns">\n    {{ \'tb.rulenode.use-metadata-interval-patterns\' | translate }}\n  </mat-checkbox>\n  <div class="tb-hint" style="padding-bottom: 16px;" translate>tb.rulenode.use-metadata-interval-patterns-hint</div>\n  <div fxLayout="column" *ngIf="getTelemetryFromDatabaseConfigForm.get(\'useMetadataIntervalPatterns\').value === false; else intervalPattern">\n    <div fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n      <mat-form-field fxFlex class="mat-block">\n        <mat-label translate>tb.rulenode.start-interval</mat-label>\n        <input type="number" step="1" min="1" max="2147483647" matInput formControlName="startInterval" required>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'startInterval\').hasError(\'required\')">\n          {{ \'tb.rulenode.start-interval-value-required\' | translate }}\n        </mat-error>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'startInterval\').hasError(\'min\')">\n          {{ \'tb.rulenode.time-value-range\' | translate }}\n        </mat-error>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'startInterval\').hasError(\'max\')">\n          {{ \'tb.rulenode.time-value-range\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex class="mat-block">\n        <mat-label translate>tb.rulenode.start-interval-time-unit</mat-label>\n        <mat-select formControlName="startIntervalTimeUnit" required>\n          <mat-option *ngFor="let timeUnit of timeUnits" [value]="timeUnit">\n            {{ timeUnitsTranslationMap.get(timeUnit) | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n    <div fxLayout="column" fxLayout.gt-sm="row" fxLayoutGap.gt-sm="8px">\n      <mat-form-field fxFlex class="mat-block">\n        <mat-label translate>tb.rulenode.end-interval</mat-label>\n        <input type="number" step="1" min="1" max="2147483647" matInput formControlName="endInterval" required>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'endInterval\').hasError(\'required\')">\n          {{ \'tb.rulenode.end-interval-value-required\' | translate }}\n        </mat-error>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'endInterval\').hasError(\'min\')">\n          {{ \'tb.rulenode.time-value-range\' | translate }}\n        </mat-error>\n        <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'endInterval\').hasError(\'max\')">\n          {{ \'tb.rulenode.time-value-range\' | translate }}\n        </mat-error>\n      </mat-form-field>\n      <mat-form-field fxFlex class="mat-block">\n        <mat-label translate>tb.rulenode.end-interval-time-unit</mat-label>\n        <mat-select formControlName="endIntervalTimeUnit" required>\n          <mat-option *ngFor="let timeUnit of timeUnits" [value]="timeUnit">\n            {{ timeUnitsTranslationMap.get(timeUnit) | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n  <ng-template #intervalPattern>\n    <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.start-interval-pattern</mat-label>\n      <input matInput formControlName="startIntervalPattern" required>\n      <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'startIntervalPattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.start-interval-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.start-interval-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n    <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n      <mat-label translate>tb.rulenode.end-interval-pattern</mat-label>\n      <input matInput formControlName="endIntervalPattern" required>\n      <mat-error *ngIf="getTelemetryFromDatabaseConfigForm.get(\'endIntervalPattern\').hasError(\'required\')">\n        {{ \'tb.rulenode.end-interval-pattern-required\' | translate }}\n      </mat-error>\n      <mat-hint innerHTML="{{ \'tb.rulenode.end-interval-pattern-hint\' | translate }}"></mat-hint>\n    </mat-form-field>\n  </ng-template>\n</section>\n',styles:[":host label.tb-title{margin-bottom:-10px}"]}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var Fe=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.relatedAttributesConfigForm},r.prototype.onConfigurationSet=function(e){this.relatedAttributesConfigForm=this.fb.group({relationsQuery:[e?e.relationsQuery:null,[i.Validators.required]],telemetry:[!!e&&e.telemetry,[]],attrMapping:[e?e.attrMapping:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-related-attributes-config",template:'<section [formGroup]="relatedAttributesConfigForm" fxLayout="column">\n  <label translate class="tb-title tb-required">tb.rulenode.relations-query</label>\n  <tb-relations-query-config\n    required\n    formControlName="relationsQuery"\n    style="padding-bottom: 15px;">\n  </tb-relations-query-config>\n  <label translate class="tb-title tb-required">tb.rulenode.attr-mapping</label>\n  <mat-checkbox fxFlex formControlName="telemetry" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.latest-telemetry\' | translate }}\n  </mat-checkbox>\n  <tb-kv-map-config\n    required\n    formControlName="attrMapping"\n    requiredText="tb.rulenode.attr-mapping-required"\n    keyText="{{ relatedAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry\' : \'tb.rulenode.source-attribute\' }}"\n    keyRequiredText="{{ relatedAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry-required\' : \'tb.rulenode.source-attribute-required\' }}"\n    valText="tb.rulenode.target-attribute"\n    valRequiredText="tb.rulenode.target-attribute-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var Te=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.tenantAttributesConfigForm},r.prototype.onConfigurationSet=function(e){this.tenantAttributesConfigForm=this.fb.group({telemetry:[!!e&&e.telemetry,[]],attrMapping:[e?e.attrMapping:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-enrichment-node-tenant-attributes-config",template:'<section [formGroup]="tenantAttributesConfigForm" fxLayout="column">\n  <label translate class="tb-title tb-required">tb.rulenode.attr-mapping</label>\n  <mat-checkbox fxFlex formControlName="telemetry" style="padding-bottom: 16px;">\n    {{ \'tb.rulenode.latest-telemetry\' | translate }}\n  </mat-checkbox>\n  <tb-kv-map-config\n    required\n    formControlName="attrMapping"\n    requiredText="tb.rulenode.attr-mapping-required"\n    keyText="{{ tenantAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry\' : \'tb.rulenode.source-attribute\' }}"\n    keyRequiredText="{{ tenantAttributesConfigForm.get(\'telemetry\').value ? \'tb.rulenode.source-telemetry-required\' : \'tb.rulenode.source-attribute-required\' }}"\n    valText="tb.rulenode.target-attribute"\n    valRequiredText="tb.rulenode.target-attribute-required">\n  </tb-kv-map-config>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var qe=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{declarations:[ge,ye,be,he,Ce,ve,Fe,Te],imports:[r.CommonModule,a.SharedModule,X],exports:[ge,ye,be,he,Ce,ve,Fe,Te]}]}],e}(),xe=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n.originatorSource=V,n.originatorSources=Object.keys(V),n.originatorSourceTranslationMap=E,n}return g(r,e),r.prototype.configForm=function(){return this.changeOriginatorConfigForm},r.prototype.onConfigurationSet=function(e){this.changeOriginatorConfigForm=this.fb.group({originatorSource:[e?e.originatorSource:null,[i.Validators.required]],relationsQuery:[e?e.relationsQuery:null,[]]})},r.prototype.validatorTriggers=function(){return["originatorSource"]},r.prototype.updateValidators=function(e){var t=this.changeOriginatorConfigForm.get("originatorSource").value;t&&t===V.RELATED?this.changeOriginatorConfigForm.get("relationsQuery").setValidators([i.Validators.required]):this.changeOriginatorConfigForm.get("relationsQuery").setValidators([]),this.changeOriginatorConfigForm.get("relationsQuery").updateValueAndValidity({emitEvent:e})},r.decorators=[{type:t.Component,args:[{selector:"tb-transformation-node-change-originator-config",template:'<section [formGroup]="changeOriginatorConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block">\n    <mat-label translate>tb.rulenode.originator-source</mat-label>\n    <mat-select formControlName="originatorSource" required>\n      <mat-option *ngFor="let source of originatorSources" [value]="source">\n        {{ originatorSourceTranslationMap.get(source) | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n  <section fxLayout="column" *ngIf="changeOriginatorConfigForm.get(\'originatorSource\').value === originatorSource.RELATED">\n    <label translate class="tb-title tb-required">tb.rulenode.relations-query</label>\n    <tb-relations-query-config\n      required\n      formControlName="relationsQuery"\n      style="padding-bottom: 15px;">\n    </tb-relations-query-config>\n  </section>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var Ie=function(e){function r(t,r,n,a){var o=e.call(this,t)||this;return o.store=t,o.fb=r,o.nodeScriptTestService=n,o.translate=a,o}return g(r,e),r.prototype.configForm=function(){return this.scriptConfigForm},r.prototype.onConfigurationSet=function(e){this.scriptConfigForm=this.fb.group({jsScript:[e?e.jsScript:null,[i.Validators.required]]})},r.prototype.testScript=function(){var e=this,t=this.scriptConfigForm.get("jsScript").value;this.nodeScriptTestService.testNodeScript(t,"update",this.translate.instant("tb.rulenode.transformer"),"Transform",["msg","metadata","msgType"],this.ruleNodeId).subscribe((function(t){t&&e.scriptConfigForm.get("jsScript").setValue(t)}))},r.prototype.onValidate=function(){this.jsFuncComponent.validateOnSubmit()},r.decorators=[{type:t.Component,args:[{selector:"tb-transformation-node-script-config",template:'<section [formGroup]="scriptConfigForm" fxLayout="column">\n  <label translate class="tb-title no-padding">tb.rulenode.transform</label>\n  <tb-js-func #jsFuncComponent\n              formControlName="jsScript"\n              functionName="Transform"\n              [functionArgs]="[\'msg\', \'metadata\', \'msgType\']"\n              noValidate="true">\n  </tb-js-func>\n  <div fxLayout="row">\n    <button mat-button mat-raised-button color="primary" (click)="testScript()">\n      {{ \'tb.rulenode.test-transformer-function\' | translate }}\n    </button>\n  </div>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder},{type:l.NodeScriptTestService},{type:n.TranslateService}]},r.propDecorators={jsFuncComponent:[{type:t.ViewChild,args:["jsFuncComponent",{static:!0}]}]},r}(a.RuleNodeConfigurationComponent);var Ne=function(e){function r(t,r){var n=e.call(this,t)||this;return n.store=t,n.fb=r,n}return g(r,e),r.prototype.configForm=function(){return this.toEmailConfigForm},r.prototype.onConfigurationSet=function(e){this.toEmailConfigForm=this.fb.group({fromTemplate:[e?e.fromTemplate:null,[i.Validators.required]],toTemplate:[e?e.toTemplate:null,[i.Validators.required]],ccTemplate:[e?e.ccTemplate:null,[]],bccTemplate:[e?e.bccTemplate:null,[]],subjectTemplate:[e?e.subjectTemplate:null,[i.Validators.required]],bodyTemplate:[e?e.bodyTemplate:null,[i.Validators.required]]})},r.decorators=[{type:t.Component,args:[{selector:"tb-transformation-node-to-email-config",template:'<section [formGroup]="toEmailConfigForm" fxLayout="column">\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.from-template</mat-label>\n    <textarea required matInput formControlName="fromTemplate" rows="2"></textarea>\n    <mat-error *ngIf="toEmailConfigForm.get(\'fromTemplate\').hasError(\'required\')">\n      {{ \'tb.rulenode.from-template-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.from-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.to-template</mat-label>\n    <textarea required matInput formControlName="toTemplate" rows="2"></textarea>\n    <mat-error *ngIf="toEmailConfigForm.get(\'toTemplate\').hasError(\'required\')">\n      {{ \'tb.rulenode.to-template-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.mail-address-list-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.cc-template</mat-label>\n    <textarea matInput formControlName="ccTemplate" rows="2"></textarea>\n    <mat-hint innerHTML="{{ \'tb.rulenode.mail-address-list-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.bcc-template</mat-label>\n    <textarea matInput formControlName="bccTemplate" rows="2"></textarea>\n    <mat-hint innerHTML="{{ \'tb.rulenode.mail-address-list-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.subject-template</mat-label>\n    <textarea required matInput formControlName="subjectTemplate" rows="2"></textarea>\n    <mat-error *ngIf="toEmailConfigForm.get(\'subjectTemplate\').hasError(\'required\')">\n      {{ \'tb.rulenode.subject-template-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.subject-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n  <mat-form-field class="mat-block" style="padding-bottom: 16px;">\n    <mat-label translate>tb.rulenode.body-template</mat-label>\n    <textarea required matInput formControlName="bodyTemplate" rows="6"></textarea>\n    <mat-error *ngIf="toEmailConfigForm.get(\'bodyTemplate\').hasError(\'required\')">\n      {{ \'tb.rulenode.body-template-required\' | translate }}\n    </mat-error>\n    <mat-hint innerHTML="{{ \'tb.rulenode.body-template-hint\' | translate }}"></mat-hint>\n  </mat-form-field>\n</section>\n'}]}],r.ctorParameters=function(){return[{type:o.Store},{type:i.FormBuilder}]},r}(a.RuleNodeConfigurationComponent);var ke=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{declarations:[xe,Ie,Ne],imports:[r.CommonModule,a.SharedModule,X],exports:[xe,Ie,Ne]}]}],e}(),Se=function(){function e(e){!function(e){e.setTranslation("en_US",{tb:{rulenode:{"create-entity-if-not-exists":"Create new entity if not exists","create-entity-if-not-exists-hint":"Create a new entity set above if it does not exist.","entity-name-pattern":"Name pattern","entity-name-pattern-required":"Name pattern is required","entity-name-pattern-hint":"Name pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","entity-type-pattern":"Type pattern","entity-type-pattern-required":"Type pattern is required","entity-type-pattern-hint":"Type pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","entity-cache-expiration":"Entities cache expiration time (sec)","entity-cache-expiration-hint":"Specifies maximum time interval allowed to store found entity records. 0 value means that records will never expire.","entity-cache-expiration-required":"Entities cache expiration time is required.","entity-cache-expiration-range":"Entities cache expiration time should be greater than or equal to 0.","customer-name-pattern":"Customer name pattern","customer-name-pattern-required":"Customer name pattern is required","create-customer-if-not-exists":"Create new customer if not exists","customer-cache-expiration":"Customers cache expiration time (sec)","customer-name-pattern-hint":"Customer name pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","customer-cache-expiration-hint":"Specifies maximum time interval allowed to store found customer records. 0 value means that records will never expire.","customer-cache-expiration-required":"Customers cache expiration time is required.","customer-cache-expiration-range":"Customers cache expiration time should be greater than or equal to 0.","start-interval":"Start Interval","end-interval":"End Interval","start-interval-time-unit":"Start Interval Time Unit","end-interval-time-unit":"End Interval Time Unit","fetch-mode":"Fetch mode","fetch-mode-hint":"If selected fetch mode 'ALL'  you able to choose telemetry sampling order.","order-by":"Order by","order-by-hint":"Select to choose telemetry sampling order.",limit:"Limit","limit-hint":"Min limit value is 2, max - 1000. In case you want to fetch a single entry, select fetch mode 'FIRST' or 'LAST'.","time-unit-milliseconds":"Milliseconds","time-unit-seconds":"Seconds","time-unit-minutes":"Minutes","time-unit-hours":"Hours","time-unit-days":"Days","time-value-range":"Time value should be in a range from 1 to 2147483647.","start-interval-value-required":"Start interval value is required.","end-interval-value-required":"End interval value is required.",filter:"Filter",switch:"Switch","message-type":"Message type","message-type-required":"Message type is required.","message-types-filter":"Message types filter","no-message-types-found":"No message types found","no-message-type-matching":"'{{messageType}}' not found.","create-new-message-type":"Create a new one!","message-types-required":"Message types are required.","client-attributes":"Client attributes","shared-attributes":"Shared attributes","server-attributes":"Server attributes","latest-timeseries":"Latest timeseries","data-keys":"Message data","metadata-keys":"Message metadata","relations-query":"Relations query","device-relations-query":"Device relations query","max-relation-level":"Max relation level","relation-type-pattern":"Relation type pattern","relation-type-pattern-hint":"Relation type pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","relation-type-pattern-required":"Relation type pattern is required","relation-types-list":"Relation types to propagate","relation-types-list-hint":"If Propagate relation types are not selected, alarms will be propagated without filtering by relation type.","unlimited-level":"Unlimited level","latest-telemetry":"Latest telemetry","attr-mapping":"Attributes mapping","source-attribute":"Source attribute","source-attribute-required":"Source attribute is required.","source-telemetry":"Source telemetry","source-telemetry-required":"Source telemetry is required.","target-attribute":"Target attribute","target-attribute-required":"Target attribute is required.","attr-mapping-required":"At least one attribute mapping should be specified.","fields-mapping":"Fields mapping","fields-mapping-required":"At least one field mapping should be specified.","source-field":"Source field","source-field-required":"Source field is required.","originator-source":"Originator source","originator-customer":"Customer","originator-tenant":"Tenant","originator-related":"Related","originator-alarm-originator":"Alarm Originator","clone-message":"Clone message",transform:"Transform","default-ttl":"Default TTL in seconds","default-ttl-required":"Default TTL is required.","min-default-ttl-message":"Only 0 minimum TTL is allowed.","message-count":"Message count (0 - unlimited)","message-count-required":"Message count is required.","min-message-count-message":"Only 0 minimum message count is allowed.","period-seconds":"Period in seconds","period-seconds-required":"Period is required.","use-metadata-period-in-seconds-patterns":"Use metadata period in seconds pattern","use-metadata-period-in-seconds-patterns-hint":"If selected, rule node use period in seconds interval pattern from message metadata assuming that intervals are in the seconds.","period-in-seconds-pattern":"Period in seconds metadata pattern","period-in-seconds-pattern-required":"Period in seconds pattern is required","period-in-seconds-pattern-hint":"Period in seconds pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","min-period-seconds-message":"Only 1 second minimum period is allowed.",originator:"Originator","message-body":"Message body","message-metadata":"Message metadata",generate:"Generate","test-generator-function":"Test generator function",generator:"Generator","test-filter-function":"Test filter function","test-switch-function":"Test switch function","test-transformer-function":"Test transformer function",transformer:"Transformer","alarm-create-condition":"Alarm create condition","test-condition-function":"Test condition function","alarm-clear-condition":"Alarm clear condition","alarm-details-builder":"Alarm details builder","test-details-function":"Test details function","alarm-type":"Alarm type","alarm-type-required":"Alarm type is required.","alarm-severity":"Alarm severity","alarm-severity-required":"Alarm severity is required",propagate:"Propagate",condition:"Condition",details:"Details","to-string":"To string","test-to-string-function":"Test to string function","from-template":"From Template","from-template-required":"From Template is required","from-template-hint":"From address template, use <code>${metaKeyName}</code> to substitute variables from metadata","to-template":"To Template","to-template-required":"To Template is required","mail-address-list-template-hint":"Comma separated address list, use <code>${metaKeyName}</code> to substitute variables from metadata","cc-template":"Cc Template","bcc-template":"Bcc Template","subject-template":"Subject Template","subject-template-required":"Subject Template is required","subject-template-hint":"Mail subject template, use <code>${metaKeyName}</code> to substitute variables from metadata","body-template":"Body Template","body-template-required":"Body Template is required","body-template-hint":"Mail body template, use <code>${metaKeyName}</code> to substitute variables from metadata","request-id-metadata-attribute":"Request Id Metadata attribute name","timeout-sec":"Timeout in seconds","timeout-required":"Timeout is required","min-timeout-message":"Only 0 minimum timeout value is allowed.","endpoint-url-pattern":"Endpoint URL pattern","endpoint-url-pattern-required":"Endpoint URL pattern is required","endpoint-url-pattern-hint":"HTTP URL address pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","request-method":"Request method","use-simple-client-http-factory":"Use simple client HTTP factory",headers:"Headers","headers-hint":"Use <code>${metaKeyName}</code> in header/value fields to substitute variables from metadata",header:"Header","header-required":"Header is required",value:"Value","value-required":"Value is required","topic-pattern":"Topic pattern","topic-pattern-required":"Topic pattern is required","mqtt-topic-pattern-hint":"MQTT topic pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","bootstrap-servers":"Bootstrap servers","bootstrap-servers-required":"Bootstrap servers value is required","other-properties":"Other properties",key:"Key","key-required":"Key is required",retries:"Automatically retry times if fails","min-retries-message":"Only 0 minimum retries is allowed.","batch-size-bytes":"Produces batch size in bytes","min-batch-size-bytes-message":"Only 0 minimum batch size is allowed.","linger-ms":"Time to buffer locally (ms)","min-linger-ms-message":"Only 0 ms minimum value is allowed.","buffer-memory-bytes":"Client buffer max size in bytes","min-buffer-memory-message":"Only 0 minimum buffer size is allowed.",acks:"Number of acknowledgments","key-serializer":"Key serializer","key-serializer-required":"Key serializer is required","value-serializer":"Value serializer","value-serializer-required":"Value serializer is required","topic-arn-pattern":"Topic ARN pattern","topic-arn-pattern-required":"Topic ARN pattern is required","topic-arn-pattern-hint":"Topic ARN pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","aws-access-key-id":"AWS Access Key ID","aws-access-key-id-required":"AWS Access Key ID is required","aws-secret-access-key":"AWS Secret Access Key","aws-secret-access-key-required":"AWS Secret Access Key is required","aws-region":"AWS Region","aws-region-required":"AWS Region is required","exchange-name-pattern":"Exchange name pattern","routing-key-pattern":"Routing key pattern","message-properties":"Message properties",host:"Host","host-required":"Host is required",port:"Port","port-required":"Port is required","port-range":"Port should be in a range from 1 to 65535.","virtual-host":"Virtual host",username:"Username",password:"Password","automatic-recovery":"Automatic recovery","connection-timeout-ms":"Connection timeout (ms)","min-connection-timeout-ms-message":"Only 0 ms minimum value is allowed.","handshake-timeout-ms":"Handshake timeout (ms)","min-handshake-timeout-ms-message":"Only 0 ms minimum value is allowed.","client-properties":"Client properties","queue-url-pattern":"Queue URL pattern","queue-url-pattern-required":"Queue URL pattern is required","queue-url-pattern-hint":"Queue URL pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","delay-seconds":"Delay (seconds)","min-delay-seconds-message":"Only 0 seconds minimum value is allowed.","max-delay-seconds-message":"Only 900 seconds maximum value is allowed.",name:"Name","name-required":"Name is required","queue-type":"Queue type","sqs-queue-standard":"Standard","sqs-queue-fifo":"FIFO","gcp-project-id":"GCP project ID","gcp-project-id-required":"GCP project ID is required","gcp-service-account-key":"GCP service account key file","gcp-service-account-key-required":"GCP service account key file is required","pubsub-topic-name":"Topic name","pubsub-topic-name-required":"Topic name is required","message-attributes":"Message attributes","message-attributes-hint":"Use <code>${metaKeyName}</code> in name/value fields to substitute variables from metadata","connect-timeout":"Connection timeout (sec)","connect-timeout-required":"Connection timeout is required.","connect-timeout-range":"Connection timeout should be in a range from 1 to 200.","client-id":"Client ID","clean-session":"Clean session","enable-ssl":"Enable SSL",credentials:"Credentials","credentials-type":"Credentials type","credentials-type-required":"Credentials type is required.","credentials-anonymous":"Anonymous","credentials-basic":"Basic","credentials-pem":"PEM","username-required":"Username is required.","password-required":"Password is required.","ca-cert":"CA certificate file *","private-key":"Private key file *",cert:"Certificate file *","no-file":"No file selected.","drop-file":"Drop a file or click to select a file to upload.","private-key-password":"Private key password","use-system-smtp-settings":"Use system SMTP settings","use-metadata-interval-patterns":"Use metadata interval patterns","use-metadata-interval-patterns-hint":"If selected, rule node use start and end interval patterns from message metadata assuming that intervals are in the milliseconds.","use-message-alarm-data":"Use message alarm data","check-all-keys":"Check that all selected keys are present","check-all-keys-hint":"If selected, checks that all specified keys are present in the message data and metadata.","check-relation-to-specific-entity":"Check relation to specific entity","check-relation-hint":"Checks existence of relation to specific entity or to any entity based on direction and relation type.","delete-relation-to-specific-entity":"Delete relation to specific entity","delete-relation-hint":"Deletes relation from the originator of the incoming message to the specified entity or list of entities based on direction and type.","remove-current-relations":"Remove current relations","remove-current-relations-hint":"Removes current relations from the originator of the incoming message based on direction and type.","change-originator-to-related-entity":"Change originator to related entity","change-originator-to-related-entity-hint":"Used to process submitted message as a message from another entity.","start-interval-pattern":"Start interval pattern","end-interval-pattern":"End interval pattern","start-interval-pattern-required":"Start interval pattern is required","end-interval-pattern-required":"End interval pattern is required","start-interval-pattern-hint":"Start interval pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","end-interval-pattern-hint":"End interval pattern, use <code>${metaKeyName}</code> to substitute variables from metadata","smtp-protocol":"Protocol","smtp-host":"SMTP host","smtp-host-required":"SMTP host is required.","smtp-port":"SMTP port","smtp-port-required":"You must supply a smtp port.","smtp-port-range":"SMTP port should be in a range from 1 to 65535.","timeout-msec":"Timeout ms","min-timeout-msec-message":"Only 0 ms minimum value is allowed.","enter-username":"Enter username","enter-password":"Enter password","enable-tls":"Enable TLS","min-period-0-seconds-message":"Only 0 second minimum period is allowed.","max-pending-messages":"Maximum pending messages","max-pending-messages-required":"Maximum pending messages is required.","max-pending-messages-range":"Maximum pending messages should be in a range from 1 to 100000.","originator-types-filter":"Originator types filter","interval-seconds":"Interval in seconds","interval-seconds-required":"Interval is required.","min-interval-seconds-message":"Only 1 second minimum interval is allowed.","output-timeseries-key-prefix":"Output timeseries key prefix","output-timeseries-key-prefix-required":"Output timeseries key prefix required.","separator-hint":'You should press "enter" to complete field input.',"entity-details":"Select entity details:","entity-details-title":"Title","entity-details-country":"Country","entity-details-state":"State","entity-details-zip":"Zip","entity-details-address":"Address","entity-details-address2":"Address2","entity-details-additional_info":"Additional Info","entity-details-phone":"Phone","entity-details-email":"Email","add-to-metadata":"Add selected details to message metadata","add-to-metadata-hint":"If selected, adds the selected details keys to the message metadata instead of message data.","entity-details-list-empty":"No entity details selected.","no-entity-details-matching":"No entity details matching were found.","custom-table-name":"Custom table name","custom-table-name-required":"Table Name is required","custom-table-hint":"You should enter the table name without prefix 'cs_tb_'.","message-field":"Message field","message-field-required":"Message field is required.","table-col":"Table column","table-col-required":"Table column is required.","latitude-key-name":"Latitude key name","longitude-key-name":"Longitude key name","latitude-key-name-required":"Latitude key name is required.","longitude-key-name-required":"Longitude key name is required.","fetch-perimeter-info-from-message-metadata":"Fetch perimeter information from message metadata","perimeter-circle":"Circle","perimeter-polygon":"Polygon","perimeter-type":"Perimeter type","circle-center-latitude":"Center latitude","circle-center-latitude-required":"Center latitude is required.","circle-center-longitude":"Center longitude","circle-center-longitude-required":"Center longitude is required.","range-unit-meter":"Meter","range-unit-kilometer":"Kilometer","range-unit-foot":"Foot","range-unit-mile":"Mile","range-unit-nautical-mile":"Nautical mile","range-units":"Range units",range:"Range","range-required":"Range is required.","polygon-definition":"Polygon definition","polygon-definition-required":"Polygon definition is required.","polygon-definition-hint":"Please, use the following format for manual definition of polygon: [[lat1,lon1],[lat2,lon2], ... ,[latN,lonN]].","min-inside-duration":"Minimal inside duration","min-inside-duration-value-required":"Minimal inside duration is required","min-inside-duration-time-unit":"Minimal inside duration time unit","min-outside-duration":"Minimal outside duration","min-outside-duration-value-required":"Minimal outside duration is required","min-outside-duration-time-unit":"Minimal outside duration time unit","tell-failure-if-absent":"Tell Failure","tell-failure-if-absent-hint":'If at least one selected key doesn\'t exist the outbound message will report "Failure".',"get-latest-value-with-ts":"Fetch Latest telemetry with Timestamp","get-latest-value-with-ts-hint":'If selected, latest telemetry values will be added to the outbound message metadata with timestamp, e.g: "temp": "&lcub;\\"ts\\":1574329385897,\\"value\\":42&rcub;"'},"key-val":{key:"Key",value:"Value","remove-entry":"Remove entry","add-entry":"Add entry"}}},!0)}(e)}return e.decorators=[{type:t.NgModule,args:[{declarations:[b],imports:[r.CommonModule,a.SharedModule],exports:[ie,fe,qe,ke,b]}]}],e.ctorParameters=function(){return[{type:n.TranslateService}]},e}();e.RuleNodeCoreConfigModule=Se,e.default=Se,e.ɵa=b,e.ɵb=ie,e.ɵba=J,e.ɵbb=Z,e.ɵbc=fe,e.ɵbd=le,e.ɵbe=se,e.ɵbf=me,e.ɵbg=ue,e.ɵbh=de,e.ɵbi=pe,e.ɵbj=ce,e.ɵbk=qe,e.ɵbl=ge,e.ɵbm=ye,e.ɵbn=be,e.ɵbo=he,e.ɵbp=Ce,e.ɵbq=ve,e.ɵbr=Fe,e.ɵbs=Te,e.ɵbt=ke,e.ɵbu=xe,e.ɵbv=Ie,e.ɵbw=Ne,e.ɵc=h,e.ɵd=C,e.ɵe=v,e.ɵf=F,e.ɵg=T,e.ɵh=q,e.ɵi=x,e.ɵj=I,e.ɵk=N,e.ɵl=k,e.ɵm=S,e.ɵn=$,e.ɵo=Q,e.ɵp=z,e.ɵq=_,e.ɵr=ee,e.ɵs=te,e.ɵt=re,e.ɵu=ne,e.ɵv=ae,e.ɵw=oe,e.ɵx=X,e.ɵy=W,e.ɵz=Y,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=rulenode-core-config.umd.min.js.map